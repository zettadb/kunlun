#include "executor/remoteScanUtils.h"
#include "executor/executor.h"
#include "nodes/makefuncs.h"
#include "nodes/relation.h"
#include "nodes/nodeFuncs.h"
#include "parser/parse_relation.h"
#include "utils/elog.h"

void InitScanTupleGenContext(ScanTupleGenContext *context, PlanState *planstate, bool skipjunk)
{
	EState *estate = planstate->state;
	Plan *plan = planstate->plan;
	List *targetList = plan->targetlist;
	int len;
	if (skipjunk)
		len = ExecCleanTargetListLength(targetList);
	else
		len = ExecTargetListLength(targetList);
	// Alloc enough; will append a column at the end of the func.
	len = (len > 3 ? len : 3);

	context->vars = NIL;
	context->exprs = NIL;
	context->estate = estate;
	context->tupledesc = CreateTemplateTupleDesc(len, false);
	context->unpushable_exprs = NIL;

	// vpc
	memset(&context->vpc, 0, sizeof(VarPickerCtx));
	context->vpc.mctx = estate->es_query_cxt;

	// rpec
	InitRemotePrintExprContext(&context->rpec, estate->es_plannedstmt->rtable);
	context->rpec.ignore_param_quals = true;
	context->rpec.rpec_param_exec_vals =
		(planstate->ps_ExprContext ? planstate->ps_ExprContext->ecxt_param_exec_vals : NULL);
	context->rpec.rpec_param_list_info = estate->es_param_list_info;

	if (IsA(planstate, RemoteScanState))
		context->rpec.ignore_param_quals = !((RemoteScanState *)planstate)->param_driven;
}

Var* lookup_scanvar_for_expr(ScanTupleGenContext *context, Expr *expr)
{
	ListCell *lc1, *lc2;
	forboth(lc1, context->exprs, lc2, context->vars)
	{
		if (equal(lfirst(lc1), expr))
			return (Var*) lfirst(lc2);
	}
	return NULL;
}

static
void alloc_scanvar_impl(ScanTupleGenContext *context, Expr *expr)
{
	char buff[12];
	int cur_resno = list_length(context->vars) + 1;
	snprintf(buff, sizeof(buff), "var$%d", cur_resno);

	Var *var = makeVar(REMOTE_VAR,
			cur_resno,
			exprType((Node *)expr),
			exprTypmod((Node *)expr),
			exprCollation((Node *)expr),
			0);

	if (cur_resno > context->tupledesc->natts)
		context->tupledesc = expandTupleDesc2(context->tupledesc);

	TupleDescInitEntry(context->tupledesc,
			cur_resno,
			buff,
			exprType((Node *)expr),
			exprTypmod((Node *)expr),
			0);

	TupleDescInitEntryCollation(context->tupledesc,
			cur_resno,
			exprCollation((Node *)expr));

	context->exprs = lappend(context->exprs, expr);
	context->vars = lappend(context->vars, var);
}

/* Return true if seperate it into multi vars */
bool alloc_scanvar_for_expr(ScanTupleGenContext *context, Expr *expr)
{
	bool split = false;
	if (IsA(expr, Var))
	{
		Var *var = (Var*)expr;
		List *fields = NULL;
		if (var->varattno == 0)
		{
			/* expand whole row var */
			List *rtables = context->estate->es_plannedstmt->rtable;
			RangeTblEntry *rte = list_nth(rtables, var->varno - 1);
			expandRTE(rte, var->varno, var->varlevelsup,
					var->location, false, NULL, &fields);
			split = true;
			context->unpushable_exprs = lappend(context->unpushable_exprs, var);
		}
		else
		{
			fields = lappend(fields, var);
		}

		/* add it to scantuple */
		ListCell *it;
		foreach(it, fields)
		{
			Var *var = (Var*)lfirst(it);
			if (!lookup_scanvar_for_expr(context, (Expr*)var))
			{
				alloc_scanvar_impl(context, (Expr*)var);
			}
		}

		return split;
	}

	VarPickerCtx *vpc = &context->vpc;
	reset_var_picker_ctx(vpc);
	if (!IsA(expr, Const))
	{
		/* 
		 * Don't do a recursive search on the phv generated by the underlying plan,
		 * treat it as an ordinary var.
		 */
		expression_tree_walker(expr, var_picker, vpc);

		if (vpc->has_alien_cols)
		{
			ereport(ERROR,
					(errcode(ERRCODE_INTERNAL_ERROR),
					 errmsg("Kunlun-db: Columns of other tables can't be in a base table scan.")));
		}
	}


	bool pushable = false;
	{
		StringInfoData buff;
		initStringInfo2(&buff, 256, context->estate->es_query_cxt);
		pushable = (snprint_expr(&buff, expr, &context->rpec) >= 0);
		pfree(buff.data);
	}
	if (!pushable || context->rpec.num_vals > 1)
		context->unpushable_exprs = lappend(context->unpushable_exprs, expr);

	if (vpc->nvars == 0)
		return split;

	/* 
	 * If the expr can be pushed down as a whole to storage node, 
	 * alloc a scantuple for it
	 */
	if (pushable && context->rpec.num_vals == 1)
	{
		if (!lookup_scanvar_for_expr(context, expr))
		{
			alloc_scanvar_impl(context, expr);
		}
	}
	else
	{
		split = true;
		/*
		   The expr has to be computed in computing node, the columns
		   involved has already been extracted, request their field
		   values instead.
		   */
		int  new_size = list_length(context->unpushable_exprs);

		for (int i = 0; i < vpc->nvars; i++)
		{
			Var *origvar = vpc->target_cols[i];
			if (!lookup_scanvar_for_expr(context, (Expr*)origvar))
			{
				alloc_scanvar_for_expr(context, (Expr*)origvar);
			}
		} // FOR vars
		
		/* only remember to orignal unpushable expression */
		context->unpushable_exprs = list_truncate(context->unpushable_exprs, new_size);
	}

	return split;
}

Node* replace_expr_with_scanvar_mutator(Node *node, ScanTupleGenContext *context)
{
	if (!node)
		return node;

	ListCell *lc1, *lc2;
	forboth(lc1, context->exprs, lc2, context->vars)
	{
		Expr *expr = (Expr*)lfirst(lc1);
		if (node == (Node*)expr || equal(node, expr))
		{
			return copyObject(lfirst(lc2));
		}
	}

	return expression_tree_mutator(node, replace_expr_with_scanvar_mutator, context);
}

Node *restore_scanvar_with_expr_mutator(Node *node, ScanTupleGenContext *context)
{
	if (!node)
		return node;

	ListCell *lc1, *lc2;
	forboth(lc1, context->vars, lc2, context->exprs)
	{
		Var *scanvar = (Var*)lfirst(lc1);
		if (node == (Node*)scanvar || equal(node, scanvar))
		{
			return lfirst(lc2);
		}
	}

	return expression_tree_mutator(node, restore_scanvar_with_expr_mutator, context);
}
