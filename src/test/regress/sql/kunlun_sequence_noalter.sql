create sequence seq2;
create table tseq2(a serial primary key, b smallserial, c bigserial, d int auto_increment, e int generated by default as identity, f int default nextval('seq2')) partition by hash(a);
create table tseq21 partition of tseq2 for values with (modulus 4, remainder 0);
create table tseq22 partition of tseq2 for values with (modulus 4, remainder 1);
create table tseq23 partition of tseq2 for values with (modulus 4, remainder 2);
create table tseq24 partition of tseq2 for values with (modulus 4, remainder 3);
insert into tseq2(e, f) values(default, default),(34, default),(default, default),(45, default);
select*from tseq2;
insert into tseq2(e) values(11),(default),(33),(default);
select*from tseq2;
insert into tseq2(f) values(111),(default),(333),(default);
select*from tseq2;



-- oracle sequence grammar
create sequence seq34 nomaxvalue nominvalue nocache nocycle noorder starts with 34;
create sequence seq35 nomaxvalue nominvalue cache 1 no cycle order starts with 35;
select seq34.nextval;
select seq35.currval;
select seq35.nextval;
select seq35.currval;
drop sequence seq35;
drop sequence seq34;

-- seq value fetch
create table t6(a int auto_increment primary key, b serial, c int generated by default as identity,d int);
insert into t6(d) values(11),(22),(33);
insert into t6(d) values(11),(22),(33);
insert into t6(d) values(11),(22),(33);
insert into t6(d) values(11),(22),(33);
select*from t6;
select currval('t6_a_seq');
select currval('t6_b_seq');
select nextval('t6_b_seq');
select currval('t6_c_seq');



create sequence seq7;
create sequence seq6;

drop table if exists t7;
create table t7(a int auto_increment primary key, b serial, c int generated by default as identity,d int default nextval('seq7'), e int);
insert into t7 (e) values(11),(22),(33) returning *;
insert into t7 (e) values(11),(22),(33) returning *;
insert into t7 (e) values(11),(22),(33) returning *;
insert into t7 (e) values(11),(22),(33) returning *;
select*from t7;
select currval('t7_a_seq');
select currval('t7_b_seq');
select currval('t7_c_seq');
select currval('seq7');
select seq7.nextval, seq7.currval, seq7.nextval, seq7.currval;
select seq6.nextval, seq7.currval, seq7.nextval, seq6.currval;

insert into t6(c,d) values(seq6.nextval, seq7.nextval),(seq6.nextval, seq7.nextval),(seq6.currval, seq7.currval);
insert into t6(c,d) values(seq6.nextval, seq7.nextval),(seq6.nextval, seq7.nextval),(seq6.currval, seq7.currval);
insert into t6(c,d) values(seq6.nextval, seq7.nextval),(seq6.nextval, seq7.nextval),(seq6.currval, seq7.currval);
insert into t6(c,d) values(seq6.currval, seq7.currval),(seq6.currval, seq7.currval),(seq6.nextval, seq7.nextval);
select*from t6;



create schema scm1;
alter sequence seq7 set schema scm1;
-- alter sequence scm1.seq7 rename to scm1.seq77;
-- above doesn't work, new name can't have schema name prepended.
-- below stmt rename a seq but doesn't move it to public schema, seq77 is still in scm1.
alter sequence scm1.seq7 rename to seq77;

select scm1.seq77.nextval, scm1.seq77.currval;
select lastval();
drop schema scm1;
drop schema scm1 cascade;

drop table t6;
drop table t7;
drop table tseq2;
drop sequence seq2;
drop sequence seq7;
drop sequence seq6;
