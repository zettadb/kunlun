-- Currently this tests polymorphic aggregates and indirectly does some
-- testing of polymorphic SQL functions.  It ought to be extended.
-- Tests for other features related to function-calling have snuck in, too.
-- Legend:
-----------
-- A = type is ANY
-- P = type is polymorphic
-- N = type is non-polymorphic
-- B = aggregate base type
-- S = aggregate state type
-- R = aggregate return type
-- 1 = arg1 of a function
-- 2 = arg2 of a function
-- ag = aggregate
-- tf = trans (state) function
-- ff = final function
-- rt = return type of a function
-- -> = implies
-- => = allowed
-- !> = not allowed
-- E  = exists
-- NE = not-exists
--
-- Possible states:
-- ----------------
-- B = (A || P || N)
--   when (B = A) -> (tf2 = NE)
-- S = (P || N)
-- ff = (E || NE)
-- tf1 = (P || N)
-- tf2 = (NE || P || N)
-- R = (P || N)
-- create functions for use as tf and ff with the needed combinations of
-- argument polymorphism, but within the constraints of valid aggregate
-- functions, i.e. tf arg1 and tf return type must match
-- polymorphic single arg transfn
CREATE FUNCTION stfp(anyarray) RETURNS anyarray AS
'select $1' LANGUAGE SQL;
CREATE FUNCTION
-- non-polymorphic single arg transfn
CREATE FUNCTION stfnp(int[]) RETURNS int[] AS
'select $1' LANGUAGE SQL;
CREATE FUNCTION
-- dual polymorphic transfn
CREATE FUNCTION tfp(anyarray,anyelement) RETURNS anyarray AS
'select $1 || $2' LANGUAGE SQL;
CREATE FUNCTION
-- dual non-polymorphic transfn
CREATE FUNCTION tfnp(int[],int) RETURNS int[] AS
'select $1 || $2' LANGUAGE SQL;
CREATE FUNCTION
-- arg1 only polymorphic transfn
CREATE FUNCTION tf1p(anyarray,int) RETURNS anyarray AS
'select $1' LANGUAGE SQL;
CREATE FUNCTION
-- arg2 only polymorphic transfn
CREATE FUNCTION tf2p(int[],anyelement) RETURNS int[] AS
'select $1' LANGUAGE SQL;
CREATE FUNCTION
-- multi-arg polymorphic
CREATE FUNCTION sum3(anyelement,anyelement,anyelement) returns anyelement AS
'select $1+$2+$3' language sql strict;
CREATE FUNCTION
-- finalfn polymorphic
CREATE FUNCTION ffp(anyarray) RETURNS anyarray AS
'select $1' LANGUAGE SQL;
CREATE FUNCTION
-- finalfn non-polymorphic
CREATE FUNCTION ffnp(int[]) returns int[] as
'select $1' LANGUAGE SQL;
CREATE FUNCTION
-- Try to cover all the possible states:
--
-- Note: in Cases 1 & 2, we are trying to return P. Therefore, if the transfn
-- is stfnp, tfnp, or tf2p, we must use ffp as finalfn, because stfnp, tfnp,
-- and tf2p do not return P. Conversely, in Cases 3 & 4, we are trying to
-- return N. Therefore, if the transfn is stfp, tfp, or tf1p, we must use ffnp
-- as finalfn, because stfp, tfp, and tf1p do not return N.
--
--     Case1 (R = P) && (B = A)
--     ------------------------
--     S    tf1
--     -------
--     N    N
-- should CREATE
CREATE AGGREGATE myaggp01a(*) (SFUNC = stfnp, STYPE = int4[],
  FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE
--     P    N
-- should ERROR: stfnp(anyarray) not matched by stfnp(int[])
CREATE AGGREGATE myaggp02a(*) (SFUNC = stfnp, STYPE = anyarray,
  FINALFUNC = ffp, INITCOND = '{}');
psql:sql/polymorphism.sql:92: ERROR:  cannot determine transition data type
DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
--     N    P
-- should CREATE
CREATE AGGREGATE myaggp03a(*) (SFUNC = stfp, STYPE = int4[],
  FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE
CREATE AGGREGATE myaggp03b(*) (SFUNC = stfp, STYPE = int4[],
  INITCOND = '{}');
CREATE AGGREGATE
--     P    P
-- should ERROR: we have no way to resolve S
CREATE AGGREGATE myaggp04a(*) (SFUNC = stfp, STYPE = anyarray,
  FINALFUNC = ffp, INITCOND = '{}');
psql:sql/polymorphism.sql:104: ERROR:  cannot determine transition data type
DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
CREATE AGGREGATE myaggp04b(*) (SFUNC = stfp, STYPE = anyarray,
  INITCOND = '{}');
psql:sql/polymorphism.sql:106: ERROR:  cannot determine transition data type
DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
--    Case2 (R = P) && ((B = P) || (B = N))
--    -------------------------------------
--    S    tf1      B    tf2
--    -----------------------
--    N    N        N    N
-- should CREATE
CREATE AGGREGATE myaggp05a(BASETYPE = int, SFUNC = tfnp, STYPE = int[],
  FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE
--    N    N        N    P
-- should CREATE
CREATE AGGREGATE myaggp06a(BASETYPE = int, SFUNC = tf2p, STYPE = int[],
  FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE
--    N    N        P    N
-- should ERROR: tfnp(int[], anyelement) not matched by tfnp(int[], int)
CREATE AGGREGATE myaggp07a(BASETYPE = anyelement, SFUNC = tfnp, STYPE = int[],
  FINALFUNC = ffp, INITCOND = '{}');
psql:sql/polymorphism.sql:126: ERROR:  function tfnp(integer[], anyelement) does not exist
--    N    N        P    P
-- should CREATE
CREATE AGGREGATE myaggp08a(BASETYPE = anyelement, SFUNC = tf2p, STYPE = int[],
  FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE
--    N    P        N    N
-- should CREATE
CREATE AGGREGATE myaggp09a(BASETYPE = int, SFUNC = tf1p, STYPE = int[],
  FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE
CREATE AGGREGATE myaggp09b(BASETYPE = int, SFUNC = tf1p, STYPE = int[],
  INITCOND = '{}');
CREATE AGGREGATE
--    N    P        N    P
-- should CREATE
CREATE AGGREGATE myaggp10a(BASETYPE = int, SFUNC = tfp, STYPE = int[],
  FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE
CREATE AGGREGATE myaggp10b(BASETYPE = int, SFUNC = tfp, STYPE = int[],
  INITCOND = '{}');
CREATE AGGREGATE
--    N    P        P    N
-- should ERROR: tf1p(int[],anyelement) not matched by tf1p(anyarray,int)
CREATE AGGREGATE myaggp11a(BASETYPE = anyelement, SFUNC = tf1p, STYPE = int[],
  FINALFUNC = ffp, INITCOND = '{}');
psql:sql/polymorphism.sql:151: ERROR:  function tf1p(integer[], anyelement) does not exist
CREATE AGGREGATE myaggp11b(BASETYPE = anyelement, SFUNC = tf1p, STYPE = int[],
  INITCOND = '{}');
psql:sql/polymorphism.sql:153: ERROR:  function tf1p(integer[], anyelement) does not exist
--    N    P        P    P
-- should ERROR: tfp(int[],anyelement) not matched by tfp(anyarray,anyelement)
CREATE AGGREGATE myaggp12a(BASETYPE = anyelement, SFUNC = tfp, STYPE = int[],
  FINALFUNC = ffp, INITCOND = '{}');
psql:sql/polymorphism.sql:158: ERROR:  function tfp(integer[], anyelement) does not exist
CREATE AGGREGATE myaggp12b(BASETYPE = anyelement, SFUNC = tfp, STYPE = int[],
  INITCOND = '{}');
psql:sql/polymorphism.sql:160: ERROR:  function tfp(integer[], anyelement) does not exist
--    P    N        N    N
-- should ERROR: tfnp(anyarray, int) not matched by tfnp(int[],int)
CREATE AGGREGATE myaggp13a(BASETYPE = int, SFUNC = tfnp, STYPE = anyarray,
  FINALFUNC = ffp, INITCOND = '{}');
psql:sql/polymorphism.sql:165: ERROR:  cannot determine transition data type
DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
--    P    N        N    P
-- should ERROR: tf2p(anyarray, int) not matched by tf2p(int[],anyelement)
CREATE AGGREGATE myaggp14a(BASETYPE = int, SFUNC = tf2p, STYPE = anyarray,
  FINALFUNC = ffp, INITCOND = '{}');
psql:sql/polymorphism.sql:170: ERROR:  cannot determine transition data type
DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
--    P    N        P    N
-- should ERROR: tfnp(anyarray, anyelement) not matched by tfnp(int[],int)
CREATE AGGREGATE myaggp15a(BASETYPE = anyelement, SFUNC = tfnp,
  STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
psql:sql/polymorphism.sql:175: ERROR:  function tfnp(anyarray, anyelement) does not exist
--    P    N        P    P
-- should ERROR: tf2p(anyarray, anyelement) not matched by tf2p(int[],anyelement)
CREATE AGGREGATE myaggp16a(BASETYPE = anyelement, SFUNC = tf2p,
  STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
psql:sql/polymorphism.sql:180: ERROR:  function tf2p(anyarray, anyelement) does not exist
--    P    P        N    N
-- should ERROR: we have no way to resolve S
CREATE AGGREGATE myaggp17a(BASETYPE = int, SFUNC = tf1p, STYPE = anyarray,
  FINALFUNC = ffp, INITCOND = '{}');
psql:sql/polymorphism.sql:185: ERROR:  cannot determine transition data type
DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
CREATE AGGREGATE myaggp17b(BASETYPE = int, SFUNC = tf1p, STYPE = anyarray,
  INITCOND = '{}');
psql:sql/polymorphism.sql:187: ERROR:  cannot determine transition data type
DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
--    P    P        N    P
-- should ERROR: tfp(anyarray, int) not matched by tfp(anyarray, anyelement)
CREATE AGGREGATE myaggp18a(BASETYPE = int, SFUNC = tfp, STYPE = anyarray,
  FINALFUNC = ffp, INITCOND = '{}');
psql:sql/polymorphism.sql:192: ERROR:  cannot determine transition data type
DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
CREATE AGGREGATE myaggp18b(BASETYPE = int, SFUNC = tfp, STYPE = anyarray,
  INITCOND = '{}');
psql:sql/polymorphism.sql:194: ERROR:  cannot determine transition data type
DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
--    P    P        P    N
-- should ERROR: tf1p(anyarray, anyelement) not matched by tf1p(anyarray, int)
CREATE AGGREGATE myaggp19a(BASETYPE = anyelement, SFUNC = tf1p,
  STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
psql:sql/polymorphism.sql:199: ERROR:  function tf1p(anyarray, anyelement) does not exist
CREATE AGGREGATE myaggp19b(BASETYPE = anyelement, SFUNC = tf1p,
  STYPE = anyarray, INITCOND = '{}');
psql:sql/polymorphism.sql:201: ERROR:  function tf1p(anyarray, anyelement) does not exist
--    P    P        P    P
-- should CREATE
CREATE AGGREGATE myaggp20a(BASETYPE = anyelement, SFUNC = tfp,
  STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE
CREATE AGGREGATE myaggp20b(BASETYPE = anyelement, SFUNC = tfp,
  STYPE = anyarray, INITCOND = '{}');
CREATE AGGREGATE
--     Case3 (R = N) && (B = A)
--     ------------------------
--     S    tf1
--     -------
--     N    N
-- should CREATE
CREATE AGGREGATE myaggn01a(*) (SFUNC = stfnp, STYPE = int4[],
  FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE
CREATE AGGREGATE myaggn01b(*) (SFUNC = stfnp, STYPE = int4[],
  INITCOND = '{}');
CREATE AGGREGATE
--     P    N
-- should ERROR: stfnp(anyarray) not matched by stfnp(int[])
CREATE AGGREGATE myaggn02a(*) (SFUNC = stfnp, STYPE = anyarray,
  FINALFUNC = ffnp, INITCOND = '{}');
psql:sql/polymorphism.sql:224: ERROR:  cannot determine transition data type
DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
CREATE AGGREGATE myaggn02b(*) (SFUNC = stfnp, STYPE = anyarray,
  INITCOND = '{}');
psql:sql/polymorphism.sql:226: ERROR:  cannot determine transition data type
DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
--     N    P
-- should CREATE
CREATE AGGREGATE myaggn03a(*) (SFUNC = stfp, STYPE = int4[],
  FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE
--     P    P
-- should ERROR: ffnp(anyarray) not matched by ffnp(int[])
CREATE AGGREGATE myaggn04a(*) (SFUNC = stfp, STYPE = anyarray,
  FINALFUNC = ffnp, INITCOND = '{}');
psql:sql/polymorphism.sql:236: ERROR:  cannot determine transition data type
DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
--    Case4 (R = N) && ((B = P) || (B = N))
--    -------------------------------------
--    S    tf1      B    tf2
--    -----------------------
--    N    N        N    N
-- should CREATE
CREATE AGGREGATE myaggn05a(BASETYPE = int, SFUNC = tfnp, STYPE = int[],
  FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE
CREATE AGGREGATE myaggn05b(BASETYPE = int, SFUNC = tfnp, STYPE = int[],
  INITCOND = '{}');
CREATE AGGREGATE
--    N    N        N    P
-- should CREATE
CREATE AGGREGATE myaggn06a(BASETYPE = int, SFUNC = tf2p, STYPE = int[],
  FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE
CREATE AGGREGATE myaggn06b(BASETYPE = int, SFUNC = tf2p, STYPE = int[],
  INITCOND = '{}');
CREATE AGGREGATE
--    N    N        P    N
-- should ERROR: tfnp(int[], anyelement) not matched by tfnp(int[], int)
CREATE AGGREGATE myaggn07a(BASETYPE = anyelement, SFUNC = tfnp, STYPE = int[],
  FINALFUNC = ffnp, INITCOND = '{}');
psql:sql/polymorphism.sql:260: ERROR:  function tfnp(integer[], anyelement) does not exist
CREATE AGGREGATE myaggn07b(BASETYPE = anyelement, SFUNC = tfnp, STYPE = int[],
  INITCOND = '{}');
psql:sql/polymorphism.sql:262: ERROR:  function tfnp(integer[], anyelement) does not exist
--    N    N        P    P
-- should CREATE
CREATE AGGREGATE myaggn08a(BASETYPE = anyelement, SFUNC = tf2p, STYPE = int[],
  FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE
CREATE AGGREGATE myaggn08b(BASETYPE = anyelement, SFUNC = tf2p, STYPE = int[],
  INITCOND = '{}');
CREATE AGGREGATE
--    N    P        N    N
-- should CREATE
CREATE AGGREGATE myaggn09a(BASETYPE = int, SFUNC = tf1p, STYPE = int[],
  FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE
--    N    P        N    P
-- should CREATE
CREATE AGGREGATE myaggn10a(BASETYPE = int, SFUNC = tfp, STYPE = int[],
  FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE
--    N    P        P    N
-- should ERROR: tf1p(int[],anyelement) not matched by tf1p(anyarray,int)
CREATE AGGREGATE myaggn11a(BASETYPE = anyelement, SFUNC = tf1p, STYPE = int[],
  FINALFUNC = ffnp, INITCOND = '{}');
psql:sql/polymorphism.sql:284: ERROR:  function tf1p(integer[], anyelement) does not exist
--    N    P        P    P
-- should ERROR: tfp(int[],anyelement) not matched by tfp(anyarray,anyelement)
CREATE AGGREGATE myaggn12a(BASETYPE = anyelement, SFUNC = tfp, STYPE = int[],
  FINALFUNC = ffnp, INITCOND = '{}');
psql:sql/polymorphism.sql:289: ERROR:  function tfp(integer[], anyelement) does not exist
--    P    N        N    N
-- should ERROR: tfnp(anyarray, int) not matched by tfnp(int[],int)
CREATE AGGREGATE myaggn13a(BASETYPE = int, SFUNC = tfnp, STYPE = anyarray,
  FINALFUNC = ffnp, INITCOND = '{}');
psql:sql/polymorphism.sql:294: ERROR:  cannot determine transition data type
DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
CREATE AGGREGATE myaggn13b(BASETYPE = int, SFUNC = tfnp, STYPE = anyarray,
  INITCOND = '{}');
psql:sql/polymorphism.sql:296: ERROR:  cannot determine transition data type
DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
--    P    N        N    P
-- should ERROR: tf2p(anyarray, int) not matched by tf2p(int[],anyelement)
CREATE AGGREGATE myaggn14a(BASETYPE = int, SFUNC = tf2p, STYPE = anyarray,
  FINALFUNC = ffnp, INITCOND = '{}');
psql:sql/polymorphism.sql:301: ERROR:  cannot determine transition data type
DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
CREATE AGGREGATE myaggn14b(BASETYPE = int, SFUNC = tf2p, STYPE = anyarray,
  INITCOND = '{}');
psql:sql/polymorphism.sql:303: ERROR:  cannot determine transition data type
DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
--    P    N        P    N
-- should ERROR: tfnp(anyarray, anyelement) not matched by tfnp(int[],int)
CREATE AGGREGATE myaggn15a(BASETYPE = anyelement, SFUNC = tfnp,
  STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
psql:sql/polymorphism.sql:308: ERROR:  function tfnp(anyarray, anyelement) does not exist
CREATE AGGREGATE myaggn15b(BASETYPE = anyelement, SFUNC = tfnp,
  STYPE = anyarray, INITCOND = '{}');
psql:sql/polymorphism.sql:310: ERROR:  function tfnp(anyarray, anyelement) does not exist
--    P    N        P    P
-- should ERROR: tf2p(anyarray, anyelement) not matched by tf2p(int[],anyelement)
CREATE AGGREGATE myaggn16a(BASETYPE = anyelement, SFUNC = tf2p,
  STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
psql:sql/polymorphism.sql:315: ERROR:  function tf2p(anyarray, anyelement) does not exist
CREATE AGGREGATE myaggn16b(BASETYPE = anyelement, SFUNC = tf2p,
  STYPE = anyarray, INITCOND = '{}');
psql:sql/polymorphism.sql:317: ERROR:  function tf2p(anyarray, anyelement) does not exist
--    P    P        N    N
-- should ERROR: ffnp(anyarray) not matched by ffnp(int[])
CREATE AGGREGATE myaggn17a(BASETYPE = int, SFUNC = tf1p, STYPE = anyarray,
  FINALFUNC = ffnp, INITCOND = '{}');
psql:sql/polymorphism.sql:322: ERROR:  cannot determine transition data type
DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
--    P    P        N    P
-- should ERROR: tfp(anyarray, int) not matched by tfp(anyarray, anyelement)
CREATE AGGREGATE myaggn18a(BASETYPE = int, SFUNC = tfp, STYPE = anyarray,
  FINALFUNC = ffnp, INITCOND = '{}');
psql:sql/polymorphism.sql:327: ERROR:  cannot determine transition data type
DETAIL:  An aggregate using a polymorphic transition type must have at least one polymorphic argument.
--    P    P        P    N
-- should ERROR: tf1p(anyarray, anyelement) not matched by tf1p(anyarray, int)
CREATE AGGREGATE myaggn19a(BASETYPE = anyelement, SFUNC = tf1p,
  STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
psql:sql/polymorphism.sql:332: ERROR:  function tf1p(anyarray, anyelement) does not exist
--    P    P        P    P
-- should ERROR: ffnp(anyarray) not matched by ffnp(int[])
CREATE AGGREGATE myaggn20a(BASETYPE = anyelement, SFUNC = tfp,
  STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
psql:sql/polymorphism.sql:337: ERROR:  function ffnp(anyarray) does not exist
-- multi-arg polymorphic
CREATE AGGREGATE mysum2(anyelement,anyelement) (SFUNC = sum3,
  STYPE = anyelement, INITCOND = '0');
CREATE AGGREGATE
-- create test data for polymorphic aggregates
create temp table t(f1 int, f2 int[], f3 text);
CREATE TABLE
insert into t values(1,array[1],'a');
INSERT 0 1
insert into t values(1,array[11],'b');
INSERT 0 1
insert into t values(1,array[111],'c');
INSERT 0 1
insert into t values(2,array[2],'a');
INSERT 0 1
insert into t values(2,array[22],'b');
INSERT 0 1
insert into t values(2,array[222],'c');
INSERT 0 1
insert into t values(3,array[3],'a');
INSERT 0 1
insert into t values(3,array[3],'b');
INSERT 0 1
-- test the successfully created polymorphic aggregates
select f3, myaggp01a(*) from t group by f3 order by f3;
 f3 | myaggp01a 
----+-----------
 a  | {}
 b  | {}
 c  | {}
(3 rows)

select f3, myaggp03a(*) from t group by f3 order by f3;
 f3 | myaggp03a 
----+-----------
 a  | {}
 b  | {}
 c  | {}
(3 rows)

select f3, myaggp03b(*) from t group by f3 order by f3;
 f3 | myaggp03b 
----+-----------
 a  | {}
 b  | {}
 c  | {}
(3 rows)

select f3, myaggp05a(f1) from t group by f3 order by f3;
 f3 | myaggp05a 
----+-----------
 a  | {1,2,3}
 b  | {1,2,3}
 c  | {1,2}
(3 rows)

select f3, myaggp06a(f1) from t group by f3 order by f3;
 f3 | myaggp06a 
----+-----------
 a  | {}
 b  | {}
 c  | {}
(3 rows)

select f3, myaggp08a(f1) from t group by f3 order by f3;
 f3 | myaggp08a 
----+-----------
 a  | {}
 b  | {}
 c  | {}
(3 rows)

select f3, myaggp09a(f1) from t group by f3 order by f3;
 f3 | myaggp09a 
----+-----------
 a  | {}
 b  | {}
 c  | {}
(3 rows)

select f3, myaggp09b(f1) from t group by f3 order by f3;
 f3 | myaggp09b 
----+-----------
 a  | {}
 b  | {}
 c  | {}
(3 rows)

select f3, myaggp10a(f1) from t group by f3 order by f3;
 f3 | myaggp10a 
----+-----------
 a  | {1,2,3}
 b  | {1,2,3}
 c  | {1,2}
(3 rows)

select f3, myaggp10b(f1) from t group by f3 order by f3;
 f3 | myaggp10b 
----+-----------
 a  | {1,2,3}
 b  | {1,2,3}
 c  | {1,2}
(3 rows)

select f3, myaggp20a(f1) from t group by f3 order by f3;
 f3 | myaggp20a 
----+-----------
 a  | {1,2,3}
 b  | {1,2,3}
 c  | {1,2}
(3 rows)

select f3, myaggp20b(f1) from t group by f3 order by f3;
 f3 | myaggp20b 
----+-----------
 a  | {1,2,3}
 b  | {1,2,3}
 c  | {1,2}
(3 rows)

select f3, myaggn01a(*) from t group by f3 order by f3;
 f3 | myaggn01a 
----+-----------
 a  | {}
 b  | {}
 c  | {}
(3 rows)

select f3, myaggn01b(*) from t group by f3 order by f3;
 f3 | myaggn01b 
----+-----------
 a  | {}
 b  | {}
 c  | {}
(3 rows)

select f3, myaggn03a(*) from t group by f3 order by f3;
 f3 | myaggn03a 
----+-----------
 a  | {}
 b  | {}
 c  | {}
(3 rows)

select f3, myaggn05a(f1) from t group by f3 order by f3;
 f3 | myaggn05a 
----+-----------
 a  | {1,2,3}
 b  | {1,2,3}
 c  | {1,2}
(3 rows)

select f3, myaggn05b(f1) from t group by f3 order by f3;
 f3 | myaggn05b 
----+-----------
 a  | {1,2,3}
 b  | {1,2,3}
 c  | {1,2}
(3 rows)

select f3, myaggn06a(f1) from t group by f3 order by f3;
 f3 | myaggn06a 
----+-----------
 a  | {}
 b  | {}
 c  | {}
(3 rows)

select f3, myaggn06b(f1) from t group by f3 order by f3;
 f3 | myaggn06b 
----+-----------
 a  | {}
 b  | {}
 c  | {}
(3 rows)

select f3, myaggn08a(f1) from t group by f3 order by f3;
 f3 | myaggn08a 
----+-----------
 a  | {}
 b  | {}
 c  | {}
(3 rows)

select f3, myaggn08b(f1) from t group by f3 order by f3;
 f3 | myaggn08b 
----+-----------
 a  | {}
 b  | {}
 c  | {}
(3 rows)

select f3, myaggn09a(f1) from t group by f3 order by f3;
 f3 | myaggn09a 
----+-----------
 a  | {}
 b  | {}
 c  | {}
(3 rows)

select f3, myaggn10a(f1) from t group by f3 order by f3;
 f3 | myaggn10a 
----+-----------
 a  | {1,2,3}
 b  | {1,2,3}
 c  | {1,2}
(3 rows)

select mysum2(f1, f1 + 1) from t;
 mysum2 
--------
     38
(1 row)

-- test inlining of polymorphic SQL functions
create function bleat(int) returns int as $$
begin
  raise notice 'bleat %', $1;
  return $1;
end$$ language plpgsql;
CREATE FUNCTION
create function sql_if(bool, anyelement, anyelement) returns anyelement as $$
select case when $1 then $2 else $3 end $$ language sql;
CREATE FUNCTION
-- Note this would fail with integer overflow, never mind wrong bleat() output,
-- if the CASE expression were not successfully inlined
select f1, sql_if(f1 > 0, bleat(f1), bleat(f1 + 1)) from int4_tbl;
psql:sql/polymorphism.sql:392: NOTICE:  bleat 1
psql:sql/polymorphism.sql:392: NOTICE:  bleat 123456
psql:sql/polymorphism.sql:392: NOTICE:  bleat -123455
psql:sql/polymorphism.sql:392: NOTICE:  bleat 2147483647
psql:sql/polymorphism.sql:392: NOTICE:  bleat -2147483646
     f1      |   sql_if    
-------------+-------------
           0 |           1
      123456 |      123456
     -123456 |     -123455
  2147483647 |  2147483647
 -2147483647 | -2147483646
(5 rows)

select q2, sql_if(q2 > 0, q2, q2 + 1) from int8_tbl;
        q2         |      sql_if       
-------------------+-------------------
               456 |               456
  4567890123456789 |  4567890123456789
               123 |               123
  4567890123456789 |  4567890123456789
 -4567890123456789 | -4567890123456788
(5 rows)

-- another sort of polymorphic aggregate
CREATE AGGREGATE array_cat_accum (anyarray)
(
    sfunc = array_cat,
    stype = anyarray,
    initcond = '{}'
);
CREATE AGGREGATE
SELECT array_cat_accum(i)
FROM (VALUES (ARRAY[1,2]), (ARRAY[3,4])) as t(i);
 array_cat_accum 
-----------------
 {1,2,3,4}
(1 row)

SELECT array_cat_accum(i)
FROM (VALUES (ARRAY[row(1,2),row(3,4)]), (ARRAY[row(5,6),row(7,8)])) as t(i);
          array_cat_accum          
-----------------------------------
 {"(1,2)","(3,4)","(5,6)","(7,8)"}
(1 row)

-- another kind of polymorphic aggregate
create function add_group(grp anyarray, ad anyelement, size integer)
  returns anyarray
  as $$
begin
	if grp is null then
    return array[ad];
  end if;
  if array_upper(grp, 1) < size then
    return grp || ad;
  end if;
  return grp;
end;
$$
  language plpgsql immutable;
CREATE FUNCTION
create aggregate build_group(anyelement, integer) (
  SFUNC = add_group,
  STYPE = anyarray
);
CREATE AGGREGATE
select build_group(q1,3) from int8_tbl;
        build_group         
----------------------------
 {123,123,4567890123456789}
(1 row)

-- this should fail because stype isn't compatible with arg
create aggregate build_group(int8, integer) (
  SFUNC = add_group,
  STYPE = int2[]
);
psql:sql/polymorphism.sql:439: ERROR:  function add_group(smallint[], bigint, integer) does not exist
-- but we can make a non-poly agg from a poly sfunc if types are OK
create aggregate build_group(int8, integer) (
  SFUNC = add_group,
  STYPE = int8[]
);
CREATE AGGREGATE
-- check proper resolution of data types for polymorphic transfn/finalfn
create function first_el(anyarray) returns anyelement as
'select $1[1]' language sql strict immutable;
CREATE FUNCTION
create aggregate first_el_agg_f8(float8) (
  SFUNC = array_append,
  STYPE = float8[],
  FINALFUNC = first_el
);
CREATE AGGREGATE
create aggregate first_el_agg_any(anyelement) (
  SFUNC = array_append,
  STYPE = anyarray,
  FINALFUNC = first_el
);
CREATE AGGREGATE
select first_el_agg_f8(x::float8) from generate_series(1,10) x;
 first_el_agg_f8 
-----------------
               1
(1 row)

select first_el_agg_any(x) from generate_series(1,10) x;
 first_el_agg_any 
------------------
                1
(1 row)

select first_el_agg_f8(x::float8) over(order by x) from generate_series(1,10) x;
 first_el_agg_f8 
-----------------
               1
               1
               1
               1
               1
               1
               1
               1
               1
               1
(10 rows)

select first_el_agg_any(x) over(order by x) from generate_series(1,10) x;
 first_el_agg_any 
------------------
                1
                1
                1
                1
                1
                1
                1
                1
                1
                1
(10 rows)

-- check that we can apply functions taking ANYARRAY to pg_stats
select distinct array_ndims(histogram_bounds) from pg_stats
where histogram_bounds is not null;
 array_ndims 
-------------
           1
(1 row)

-- such functions must protect themselves if varying element type isn't OK
-- (WHERE clause here is to avoid possibly getting a collation error instead)
select max(histogram_bounds) from pg_stats where tablename = 'pg_am';
psql:sql/polymorphism.sql:475: ERROR:  cannot compare arrays of different element types
-- test variadic polymorphic functions
create function myleast(variadic anyarray) returns anyelement as $$
  select min($1[i]) from generate_subscripts($1,1) g(i)
$$ language sql immutable strict;
CREATE FUNCTION
select myleast(10, 1, 20, 33);
 myleast 
---------
       1
(1 row)

select myleast(1.1, 0.22, 0.55);
 myleast 
---------
    0.22
(1 row)

select myleast('z'::text);
 myleast 
---------
 z
(1 row)

select myleast(); -- fail
psql:sql/polymorphism.sql:486: ERROR:  function myleast() does not exist
LINE 1: select myleast();
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-- test with variadic call parameter
select myleast(variadic array[1,2,3,4,-1]);
 myleast 
---------
      -1
(1 row)

select myleast(variadic array[1.1, -5.5]);
 myleast 
---------
    -5.5
(1 row)

--test with empty variadic call parameter
select myleast(variadic array[]::int[]);
 myleast 
---------
        
(1 row)

-- an example with some ordinary arguments too
create function concat(text, variadic anyarray) returns text as $$
  select array_to_string($2, $1);
$$ language sql immutable strict;
CREATE FUNCTION
select concat('%', 1, 2, 3, 4, 5);
  concat   
-----------
 1%2%3%4%5
(1 row)

select concat('|', 'a'::text, 'b', 'c');
 concat 
--------
 a|b|c
(1 row)

select concat('|', variadic array[1,2,33]);
 concat 
--------
 1|2|33
(1 row)

select concat('|', variadic array[]::int[]);
 concat 
--------
 
(1 row)

drop function concat(text, anyarray);
DROP FUNCTION
-- mix variadic with anyelement
create function formarray(anyelement, variadic anyarray) returns anyarray as $$
  select array_prepend($1, $2);
$$ language sql immutable strict;
CREATE FUNCTION
select formarray(1,2,3,4,5);
  formarray  
-------------
 {1,2,3,4,5}
(1 row)

select formarray(1.1, variadic array[1.2,55.5]);
   formarray    
----------------
 {1.1,1.2,55.5}
(1 row)

select formarray(1.1, array[1.2,55.5]); -- fail without variadic
psql:sql/polymorphism.sql:514: ERROR:  function formarray(numeric, numeric[]) does not exist
LINE 1: select formarray(1.1, array[1.2,55.5]);
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
select formarray(1, 'x'::text); -- fail, type mismatch
psql:sql/polymorphism.sql:515: ERROR:  function formarray(integer, text) does not exist
LINE 1: select formarray(1, 'x'::text);
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
select formarray(1, variadic array['x'::text]); -- fail, type mismatch
psql:sql/polymorphism.sql:516: ERROR:  function formarray(integer, text[]) does not exist
LINE 1: select formarray(1, variadic array['x'::text]);
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
drop function formarray(anyelement, variadic anyarray);
DROP FUNCTION
-- test pg_typeof() function
select pg_typeof(null);           -- unknown
 pg_typeof 
-----------
 unknown
(1 row)

select pg_typeof(0);              -- integer
 pg_typeof 
-----------
 integer
(1 row)

select pg_typeof(0.0);            -- numeric
 pg_typeof 
-----------
 numeric
(1 row)

select pg_typeof(1+1 = 2);        -- boolean
 pg_typeof 
-----------
 boolean
(1 row)

select pg_typeof('x');            -- unknown
 pg_typeof 
-----------
 unknown
(1 row)

select pg_typeof('' || '');       -- text
 pg_typeof 
-----------
 text
(1 row)

select pg_typeof(pg_typeof(0));   -- regtype
 pg_typeof 
-----------
 regtype
(1 row)

select pg_typeof(array[1.2,55.5]); -- numeric[]
 pg_typeof 
-----------
 numeric[]
(1 row)

select pg_typeof(myleast(10, 1, 20, 33));  -- polymorphic input
 pg_typeof 
-----------
 integer
(1 row)

-- test functions with default parameters
-- test basic functionality
create function dfunc(a int = 1, int = 2) returns int as $$
  select $1 + $2;
$$ language sql;
CREATE FUNCTION
select dfunc();
 dfunc 
-------
     3
(1 row)

select dfunc(10);
 dfunc 
-------
    12
(1 row)

select dfunc(10, 20);
 dfunc 
-------
    30
(1 row)

select dfunc(10, 20, 30);  -- fail
psql:sql/polymorphism.sql:541: ERROR:  function dfunc(integer, integer, integer) does not exist
LINE 1: select dfunc(10, 20, 30);
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
drop function dfunc();  -- fail
psql:sql/polymorphism.sql:543: ERROR:  function dfunc() does not exist
drop function dfunc(int);  -- fail
psql:sql/polymorphism.sql:544: ERROR:  function dfunc(integer) does not exist
drop function dfunc(int, int);  -- ok
DROP FUNCTION
-- fail: defaults must be at end of argument list
create function dfunc(a int = 1, b int) returns int as $$
  select $1 + $2;
$$ language sql;
psql:sql/polymorphism.sql:550: ERROR:  input parameters after one with a default value must also have defaults
-- however, this should work:
create function dfunc(a int = 1, out sum int, b int = 2) as $$
  select $1 + $2;
$$ language sql;
CREATE FUNCTION
select dfunc();
 dfunc 
-------
     3
(1 row)

-- verify it lists properly
\df dfunc
                                          List of functions
 schema | name  | result data type |                    argument data types                    | type 
--------+-------+------------------+-----------------------------------------------------------+------
 public | dfunc | integer          | a integer DEFAULT 1, OUT sum integer, b integer DEFAULT 2 | func
(1 row)

drop function dfunc(int, int);
DROP FUNCTION
-- check implicit coercion
create function dfunc(a int DEFAULT 1.0, int DEFAULT '-1') returns int as $$
  select $1 + $2;
$$ language sql;
CREATE FUNCTION
select dfunc();
 dfunc 
-------
     0
(1 row)

create function dfunc(a text DEFAULT 'Hello', b text DEFAULT 'World') returns text as $$
  select $1 || ', ' || $2;
$$ language sql;
CREATE FUNCTION
select dfunc();  -- fail: which dfunc should be called? int or text
psql:sql/polymorphism.sql:573: ERROR:  function dfunc() is not unique
LINE 1: select dfunc();
               ^
HINT:  Could not choose a best candidate function. You might need to add explicit type casts.
select dfunc('Hi');  -- ok
   dfunc   
-----------
 Hi, World
(1 row)

select dfunc('Hi', 'City');  -- ok
  dfunc   
----------
 Hi, City
(1 row)

select dfunc(0);  -- ok
 dfunc 
-------
    -1
(1 row)

select dfunc(10, 20);  -- ok
 dfunc 
-------
    30
(1 row)

drop function dfunc(int, int);
DROP FUNCTION
drop function dfunc(text, text);
DROP FUNCTION
create function dfunc(int = 1, int = 2) returns int as $$
  select 2;
$$ language sql;
CREATE FUNCTION
create function dfunc(int = 1, int = 2, int = 3, int = 4) returns int as $$
  select 4;
$$ language sql;
CREATE FUNCTION
-- Now, dfunc(nargs = 2) and dfunc(nargs = 4) are ambiguous when called
-- with 0 to 2 arguments.
select dfunc();  -- fail
psql:sql/polymorphism.sql:593: ERROR:  function dfunc() is not unique
LINE 1: select dfunc();
               ^
HINT:  Could not choose a best candidate function. You might need to add explicit type casts.
select dfunc(1);  -- fail
psql:sql/polymorphism.sql:594: ERROR:  function dfunc(integer) is not unique
LINE 1: select dfunc(1);
               ^
HINT:  Could not choose a best candidate function. You might need to add explicit type casts.
select dfunc(1, 2);  -- fail
psql:sql/polymorphism.sql:595: ERROR:  function dfunc(integer, integer) is not unique
LINE 1: select dfunc(1, 2);
               ^
HINT:  Could not choose a best candidate function. You might need to add explicit type casts.
select dfunc(1, 2, 3);  -- ok
 dfunc 
-------
     4
(1 row)

select dfunc(1, 2, 3, 4);  -- ok
 dfunc 
-------
     4
(1 row)

drop function dfunc(int, int);
DROP FUNCTION
drop function dfunc(int, int, int, int);
DROP FUNCTION
-- default values are not allowed for output parameters
create function dfunc(out int = 20) returns int as $$
  select 1;
$$ language sql;
psql:sql/polymorphism.sql:605: ERROR:  only input parameters can have default values
-- polymorphic parameter test
create function dfunc(anyelement = 'World'::text) returns text as $$
  select 'Hello, ' || $1::text;
$$ language sql;
CREATE FUNCTION
select dfunc();
    dfunc     
--------------
 Hello, World
(1 row)

select dfunc(0);
  dfunc   
----------
 Hello, 0
(1 row)

select dfunc(to_date('20081215','YYYYMMDD'));
       dfunc       
-------------------
 Hello, 2008-12-15
(1 row)

select dfunc('City'::text);
    dfunc    
-------------
 Hello, City
(1 row)

drop function dfunc(anyelement);
DROP FUNCTION
-- check defaults for variadics
create function dfunc(a variadic int[]) returns int as
$$ select array_upper($1, 1) $$ language sql;
CREATE FUNCTION
select dfunc();  -- fail
psql:sql/polymorphism.sql:624: ERROR:  function dfunc() does not exist
LINE 1: select dfunc();
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
select dfunc(10);
 dfunc 
-------
     1
(1 row)

select dfunc(10,20);
 dfunc 
-------
     2
(1 row)

create or replace function dfunc(a variadic int[] default array[]::int[]) returns int as
$$ select array_upper($1, 1) $$ language sql;
CREATE FUNCTION
select dfunc();  -- now ok
 dfunc 
-------
      
(1 row)

select dfunc(10);
 dfunc 
-------
     1
(1 row)

select dfunc(10,20);
 dfunc 
-------
     2
(1 row)

-- can't remove the default once it exists
create or replace function dfunc(a variadic int[]) returns int as
$$ select array_upper($1, 1) $$ language sql;
psql:sql/polymorphism.sql:637: ERROR:  cannot remove parameter defaults from existing function
HINT:  Use DROP FUNCTION dfunc(integer[]) first.
\df dfunc
                                     List of functions
 schema | name  | result data type |               argument data types               | type 
--------+-------+------------------+-------------------------------------------------+------
 public | dfunc | integer          | VARIADIC a integer[] DEFAULT ARRAY[]::integer[] | func
(1 row)

drop function dfunc(a variadic int[]);
DROP FUNCTION
-- Ambiguity should be reported only if there's not a better match available
create function dfunc(int = 1, int = 2, int = 3) returns int as $$
  select 3;
$$ language sql;
CREATE FUNCTION
create function dfunc(int = 1, int = 2) returns int as $$
  select 2;
$$ language sql;
CREATE FUNCTION
create function dfunc(text) returns text as $$
  select $1;
$$ language sql;
CREATE FUNCTION
-- dfunc(narg=2) and dfunc(narg=3) are ambiguous
select dfunc(1);  -- fail
psql:sql/polymorphism.sql:657: ERROR:  function dfunc(integer) is not unique
LINE 1: select dfunc(1);
               ^
HINT:  Could not choose a best candidate function. You might need to add explicit type casts.
-- but this works since the ambiguous functions aren't preferred anyway
select dfunc('Hi');
 dfunc 
-------
 Hi
(1 row)

drop function dfunc(int, int, int);
DROP FUNCTION
drop function dfunc(int, int);
DROP FUNCTION
drop function dfunc(text);
DROP FUNCTION
--
-- Tests for named- and mixed-notation function calling
--
create function dfunc(a int, b int, c int = 0, d int = 0)
  returns table (a int, b int, c int, d int) as $$
  select $1, $2, $3, $4;
$$ language sql;
CREATE FUNCTION
select (dfunc(10,20,30)).*;
 a  | b  | c  | d 
----+----+----+---
 10 | 20 | 30 | 0
(1 row)

select (dfunc(a = 10, b = 20, c = 30)).*;
psql:sql/polymorphism.sql:676: ERROR:  column "a" does not exist
LINE 1: select (dfunc(a = 10, b = 20, c = 30)).*;
                      ^
select * from dfunc(a = 10, b = 20);
psql:sql/polymorphism.sql:677: ERROR:  column "a" does not exist
LINE 1: select * from dfunc(a = 10, b = 20);
                            ^
select * from dfunc(b = 10, a = 20);
psql:sql/polymorphism.sql:678: ERROR:  column "b" does not exist
LINE 1: select * from dfunc(b = 10, a = 20);
                            ^
select * from dfunc(0);  -- fail
psql:sql/polymorphism.sql:679: ERROR:  function dfunc(integer) does not exist
LINE 1: select * from dfunc(0);
                      ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
select * from dfunc(1,2);
 a | b | c | d 
---+---+---+---
 1 | 2 | 0 | 0
(1 row)

select * from dfunc(1,2,c = 3);
psql:sql/polymorphism.sql:681: ERROR:  column "c" does not exist
LINE 1: select * from dfunc(1,2,c = 3);
                                ^
select * from dfunc(1,2,d = 3);
psql:sql/polymorphism.sql:682: ERROR:  column "d" does not exist
LINE 1: select * from dfunc(1,2,d = 3);
                                ^
select * from dfunc(x = 20, b = 10, x = 30);  -- fail, duplicate name
psql:sql/polymorphism.sql:684: ERROR:  column "x" does not exist
LINE 1: select * from dfunc(x = 20, b = 10, x = 30);
                            ^
select * from dfunc(10, b = 20, 30);  -- fail, named args must be last
psql:sql/polymorphism.sql:685: ERROR:  column "b" does not exist
LINE 1: select * from dfunc(10, b = 20, 30);
                                ^
select * from dfunc(x = 10, b = 20, c = 30);  -- fail, unknown param
psql:sql/polymorphism.sql:686: ERROR:  column "x" does not exist
LINE 1: select * from dfunc(x = 10, b = 20, c = 30);
                            ^
select * from dfunc(10, 10, a = 20);  -- fail, a overlaps positional parameter
psql:sql/polymorphism.sql:687: ERROR:  column "a" does not exist
LINE 1: select * from dfunc(10, 10, a = 20);
                                    ^
select * from dfunc(1,c = 2,d = 3); -- fail, no value for b
psql:sql/polymorphism.sql:688: ERROR:  column "c" does not exist
LINE 1: select * from dfunc(1,c = 2,d = 3);
                              ^
drop function dfunc(int, int, int, int);
DROP FUNCTION
-- test with different parameter types
create function dfunc(a varchar, b numeric, c date = current_date)
  returns table (a varchar, b numeric, c date) as $$
  select $1, $2, $3;
$$ language sql;
CREATE FUNCTION
select (dfunc('Hello World', 20, '2009-07-25'::date)).*;
      a      | b  |     c      
-------------+----+------------
 Hello World | 20 | 2009-07-25
(1 row)

select * from dfunc('Hello World', 20, '2009-07-25'::date);
      a      | b  |     c      
-------------+----+------------
 Hello World | 20 | 2009-07-25
(1 row)

select * from dfunc(c = '2009-07-25'::date, a = 'Hello World', b = 20);
psql:sql/polymorphism.sql:700: ERROR:  column "c" does not exist
LINE 1: select * from dfunc(c = '2009-07-25'::date, a = 'Hello World...
                            ^
select * from dfunc('Hello World', b = 20, c = '2009-07-25'::date);
psql:sql/polymorphism.sql:701: ERROR:  column "b" does not exist
LINE 1: select * from dfunc('Hello World', b = 20, c = '2009-07-25':...
                                           ^
select * from dfunc('Hello World', c = '2009-07-25'::date, b = 20);
psql:sql/polymorphism.sql:702: ERROR:  column "c" does not exist
LINE 1: select * from dfunc('Hello World', c = '2009-07-25'::date, b...
                                           ^
select * from dfunc('Hello World', c = 20, b = '2009-07-25'::date);  -- fail
psql:sql/polymorphism.sql:703: ERROR:  column "c" does not exist
LINE 1: select * from dfunc('Hello World', c = 20, b = '2009-07-25':...
                                           ^
drop function dfunc(varchar, numeric, date);
DROP FUNCTION
-- test out parameters with named params
create function dfunc(a varchar = 'def a', out _a varchar, c numeric = NULL, out _c numeric)
returns record as $$
  select $1, $2;
$$ language sql;
CREATE FUNCTION
select (dfunc()).*;
  _a   | _c 
-------+----
 def a |   
(1 row)

select * from dfunc();
  _a   | _c 
-------+----
 def a |   
(1 row)

select * from dfunc('Hello', 100);
  _a   | _c  
-------+-----
 Hello | 100
(1 row)

select * from dfunc(a = 'Hello', c = 100);
psql:sql/polymorphism.sql:716: ERROR:  column "a" does not exist
LINE 1: select * from dfunc(a = 'Hello', c = 100);
                            ^
select * from dfunc(c = 100, a = 'Hello');
psql:sql/polymorphism.sql:717: ERROR:  column "c" does not exist
LINE 1: select * from dfunc(c = 100, a = 'Hello');
                            ^
select * from dfunc('Hello');
  _a   | _c 
-------+----
 Hello |   
(1 row)

select * from dfunc('Hello', c = 100);
psql:sql/polymorphism.sql:719: ERROR:  column "c" does not exist
LINE 1: select * from dfunc('Hello', c = 100);
                                     ^
select * from dfunc(c = 100);
psql:sql/polymorphism.sql:720: ERROR:  column "c" does not exist
LINE 1: select * from dfunc(c = 100);
                            ^
-- fail, can no longer change an input parameter's name
create or replace function dfunc(a varchar = 'def a', out _a varchar, x numeric = NULL, out _c numeric)
returns record as $$
  select $1, $2;
$$ language sql;
psql:sql/polymorphism.sql:726: ERROR:  cannot change name of input parameter "c"
HINT:  Use DROP FUNCTION dfunc(character varying,numeric) first.
create or replace function dfunc(a varchar = 'def a', out _a varchar, numeric = NULL, out _c numeric)
returns record as $$
  select $1, $2;
$$ language sql;
psql:sql/polymorphism.sql:731: ERROR:  cannot change name of input parameter "c"
HINT:  Use DROP FUNCTION dfunc(character varying,numeric) first.
drop function dfunc(varchar, numeric);
DROP FUNCTION
--fail, named parameters are not unique
create function testpolym(a int, a int) returns int as $$ select 1;$$ language sql;
psql:sql/polymorphism.sql:736: ERROR:  parameter name "a" used more than once
create function testpolym(int, out a int, out a int) returns int as $$ select 1;$$ language sql;
psql:sql/polymorphism.sql:737: ERROR:  parameter name "a" used more than once
create function testpolym(out a int, inout a int) returns int as $$ select 1;$$ language sql;
psql:sql/polymorphism.sql:738: ERROR:  parameter name "a" used more than once
create function testpolym(a int, inout a int) returns int as $$ select 1;$$ language sql;
psql:sql/polymorphism.sql:739: ERROR:  parameter name "a" used more than once
-- valid
create function testpolym(a int, out a int) returns int as $$ select $1;$$ language sql;
CREATE FUNCTION
select testpolym(37);
 testpolym 
-----------
        37
(1 row)

drop function testpolym(int);
DROP FUNCTION
create function testpolym(a int) returns table(a int) as $$ select $1;$$ language sql;
CREATE FUNCTION
select * from testpolym(37);
 a  
----
 37
(1 row)

drop function testpolym(int);
DROP FUNCTION
-- test polymorphic params and defaults
create function dfunc(a anyelement, b anyelement = null, flag bool = true)
returns anyelement as $$
  select case when $3 then $1 else $2 end;
$$ language sql;
CREATE FUNCTION
select dfunc(1,2);
 dfunc 
-------
     1
(1 row)

select dfunc('a'::text, 'b'); -- positional notation with default
 dfunc 
-------
 a
(1 row)

select dfunc(a = 1, b = 2);
psql:sql/polymorphism.sql:758: ERROR:  column "a" does not exist
LINE 1: select dfunc(a = 1, b = 2);
                     ^
select dfunc(a = 'a'::text, b = 'b');
psql:sql/polymorphism.sql:759: ERROR:  column "a" does not exist
LINE 1: select dfunc(a = 'a'::text, b = 'b');
                     ^
select dfunc(a = 'a'::text, b = 'b', flag = false); -- named notation
psql:sql/polymorphism.sql:760: ERROR:  column "a" does not exist
LINE 1: select dfunc(a = 'a'::text, b = 'b', flag = false);
                     ^
select dfunc(b = 'b'::text, a = 'a'); -- named notation with default
psql:sql/polymorphism.sql:762: ERROR:  column "b" does not exist
LINE 1: select dfunc(b = 'b'::text, a = 'a');
                     ^
select dfunc(a = 'a'::text, flag = true); -- named notation with default
psql:sql/polymorphism.sql:763: ERROR:  column "a" does not exist
LINE 1: select dfunc(a = 'a'::text, flag = true);
                     ^
select dfunc(a = 'a'::text, flag = false); -- named notation with default
psql:sql/polymorphism.sql:764: ERROR:  column "a" does not exist
LINE 1: select dfunc(a = 'a'::text, flag = false);
                     ^
select dfunc(b = 'b'::text, a = 'a', flag = true); -- named notation
psql:sql/polymorphism.sql:765: ERROR:  column "b" does not exist
LINE 1: select dfunc(b = 'b'::text, a = 'a', flag = true);
                     ^
select dfunc('a'::text, 'b', false); -- full positional notation
 dfunc 
-------
 b
(1 row)

select dfunc('a'::text, 'b', flag = false); -- mixed notation
psql:sql/polymorphism.sql:768: ERROR:  column "flag" does not exist
LINE 1: select dfunc('a'::text, 'b', flag = false);
                                     ^
select dfunc('a'::text, 'b', true); -- full positional notation
 dfunc 
-------
 a
(1 row)

select dfunc('a'::text, 'b', flag = true); -- mixed notation
psql:sql/polymorphism.sql:770: ERROR:  column "flag" does not exist
LINE 1: select dfunc('a'::text, 'b', flag = true);
                                     ^
-- ansi/sql syntax
select dfunc(a => 1, b => 2);
 dfunc 
-------
     1
(1 row)

select dfunc(a => 'a'::text, b => 'b');
 dfunc 
-------
 a
(1 row)

select dfunc(a => 'a'::text, b => 'b', flag => false); -- named notation
 dfunc 
-------
 b
(1 row)

select dfunc(b => 'b'::text, a => 'a'); -- named notation with default
 dfunc 
-------
 a
(1 row)

select dfunc(a => 'a'::text, flag => true); -- named notation with default
 dfunc 
-------
 a
(1 row)

select dfunc(a => 'a'::text, flag => false); -- named notation with default
 dfunc 
-------
 
(1 row)

select dfunc(b => 'b'::text, a => 'a', flag => true); -- named notation
 dfunc 
-------
 a
(1 row)

select dfunc('a'::text, 'b', false); -- full positional notation
 dfunc 
-------
 b
(1 row)

select dfunc('a'::text, 'b', flag => false); -- mixed notation
 dfunc 
-------
 b
(1 row)

select dfunc('a'::text, 'b', true); -- full positional notation
 dfunc 
-------
 a
(1 row)

select dfunc('a'::text, 'b', flag => true); -- mixed notation
 dfunc 
-------
 a
(1 row)

-- this tests lexer edge cases around =>
select dfunc(a =>-1);
 dfunc 
-------
    -1
(1 row)

select dfunc(a =>+1);
 dfunc 
-------
     1
(1 row)

select dfunc(a =>/**/1);
 dfunc 
-------
     1
(1 row)

select dfunc(a =>--comment to be removed by psql
  1);
 dfunc 
-------
     1
(1 row)

-- need DO to protect the -- from psql
do $$
  declare r integer;
  begin
    select dfunc(a=>-- comment
      1) into r;
    raise info 'r = %', r;
  end;
$$;
psql:sql/polymorphism.sql:801: INFO:  r = 1
DO
-- check reverse-listing of named-arg calls
CREATE VIEW dfview AS
   SELECT q1, q2,
     dfunc(q1,q2, flag = q1>q2) as c3,
     dfunc(q1, flag = q1<q2, b = q2) as c4
     FROM int8_tbl;
psql:sql/polymorphism.sql:808: ERROR:  syntax error at or near ">"
LINE 3:      dfunc(q1,q2, flag = q1>q2) as c3,
                                   ^
 
select * from dfview;
psql:sql/polymorphism.sql:810: ERROR:  relation "dfview" does not exist
LINE 1: select * from dfview;
                      ^
\d+ dfview
psql:sql/polymorphism.sql:812: error: Did not find any relation named "dfview".
drop view dfview;
psql:sql/polymorphism.sql:814: ERROR:  view "dfview" does not exist
drop function dfunc(anyelement, anyelement, bool);
DROP FUNCTION
