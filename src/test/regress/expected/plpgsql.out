--
-- PLPGSQL
--
-- Scenario:
--
--     A building with a modern TP cable installation where any
--     of the wall connectors can be used to plug in phones,
--     ethernet interfaces or local office hubs. The backside
--     of the wall connectors is wired to one of several patch-
--     fields in the building.
--
--     In the patchfields, there are hubs and all the slots
--     representing the wall connectors. In addition there are
--     slots that can represent a phone line from the central
--     phone system.
--
--     Triggers ensure consistency of the patching information.
--
--     Functions are used to build up powerful views that let
--     you look behind the wall when looking at a patchfield
--     or into a room.
--
drop table if exists Room;
psql:sql/plpgsql.sql:24: NOTICE:  table "room" does not exist, skipping
DROP TABLE
create table Room (
    roomno	char(8),
    comment	text
);
CREATE TABLE
create unique index Room_rno on Room using btree (roomno bpchar_ops);
CREATE INDEX
drop table if exists WSlot;
psql:sql/plpgsql.sql:31: NOTICE:  table "wslot" does not exist, skipping
DROP TABLE
create table WSlot (
    slotname	char(20),
    roomno	char(8),
    slotlink	char(20),
    backlink	char(20)
);
CREATE TABLE
create unique index WSlot_name on WSlot using btree (slotname bpchar_ops);
CREATE INDEX
drop table if exists PField;
psql:sql/plpgsql.sql:40: NOTICE:  table "pfield" does not exist, skipping
DROP TABLE
create table PField (
    name	text,
    comment	text
);
CREATE TABLE
create unique index PField_name on PField using btree (name text_ops);
CREATE INDEX
drop table if exists PSlot;
psql:sql/plpgsql.sql:47: NOTICE:  table "pslot" does not exist, skipping
DROP TABLE
create table PSlot (
    slotname	char(20),
    pfname	text,
    slotlink	char(20),
    backlink	char(20)
);
CREATE TABLE
create unique index PSlot_name on PSlot using btree (slotname bpchar_ops);
CREATE INDEX
drop table if exists PLine;
psql:sql/plpgsql.sql:56: NOTICE:  table "pline" does not exist, skipping
DROP TABLE
create table PLine (
    slotname	char(20),
    phonenumber	char(20),
    comment	text,
    backlink	char(20)
);
CREATE TABLE
create unique index PLine_name on PLine using btree (slotname bpchar_ops);
CREATE INDEX
drop table if exists Hub;
psql:sql/plpgsql.sql:65: NOTICE:  table "hub" does not exist, skipping
DROP TABLE
create table Hub (
    name	char(14),
    comment	text,
    nslots	integer
);
CREATE TABLE
create unique index Hub_name on Hub using btree (name bpchar_ops);
CREATE INDEX
drop table if exists HSlot;
psql:sql/plpgsql.sql:73: NOTICE:  table "hslot" does not exist, skipping
DROP TABLE
create table HSlot (
    slotname	char(20),
    hubname	char(14),
    slotno	integer,
    slotlink	char(20)
);
CREATE TABLE
create unique index HSlot_name on HSlot using btree (slotname bpchar_ops);
CREATE INDEX
create index HSlot_hubname on HSlot using btree (hubname bpchar_ops);
CREATE INDEX
drop table if exists System;
psql:sql/plpgsql.sql:83: NOTICE:  table "system" does not exist, skipping
DROP TABLE
create table System (
    name	text,
    comment	text
);
CREATE TABLE
create unique index System_name on System using btree (name text_ops);
CREATE INDEX
drop table if exists IFace;
psql:sql/plpgsql.sql:90: NOTICE:  table "iface" does not exist, skipping
DROP TABLE
create table IFace (
    slotname	char(20),
    sysname	text,
    ifname	text,
    slotlink	char(20)
);
CREATE TABLE
create unique index IFace_name on IFace using btree (slotname bpchar_ops);
CREATE INDEX
drop table if exists PHone;
psql:sql/plpgsql.sql:99: NOTICE:  table "phone" does not exist, skipping
DROP TABLE
create table PHone (
    slotname	char(20),
    comment	text,
    slotlink	char(20)
);
CREATE TABLE
create unique index PHone_name on PHone using btree (slotname bpchar_ops);
CREATE INDEX
-- Test comments
COMMENT ON FUNCTION tg_hub_adjustslots_wrong(bpchar, integer, integer) IS 'function with args';
psql:sql/plpgsql.sql:109: ERROR:  function tg_hub_adjustslots_wrong(character, integer, integer) does not exist
COMMENT ON FUNCTION tg_hub_adjustslots(bpchar, integer, integer) IS 'function with args';
psql:sql/plpgsql.sql:110: ERROR:  function tg_hub_adjustslots(character, integer, integer) does not exist
COMMENT ON FUNCTION tg_hub_adjustslots(bpchar, integer, integer) IS NULL;
psql:sql/plpgsql.sql:111: ERROR:  function tg_hub_adjustslots(character, integer, integer) does not exist
create function tg_slotlink_set(bpchar, bpchar)
returns integer as '
declare
    myname	alias for $1;
    blname	alias for $2;
    mytype	char(2);
    link	char(4);
    rec		record;
begin
    mytype = substr(myname, 1, 2);
    link = mytype || substr(blname, 1, 2);
    if link = ''PHPH'' then
        raise exception
		''slotlink between two phones does not make sense'';
    end if;
    if link in (''PHHS'', ''HSPH'') then
        raise exception
		''link of phone to hub does not make sense'';
    end if;
    if link in (''PHIF'', ''IFPH'') then
        raise exception
		''link of phone to hub does not make sense'';
    end if;
    if link in (''PSWS'', ''WSPS'') then
        raise exception
		''slotlink from patchslot to wallslot not permitted'';
    end if;
    if mytype = ''PS'' then
        select into rec * from PSlot where slotname = myname;
	if not found then
	    raise exception 'x'% does not exist'', myname;
	end if;
	if rec.slotlink != blname then
	    update PSlot set slotlink = blname where slotname = myname;
	end if;
	return 0;
    end if;
    if mytype = ''WS'' then
        select into rec * from WSlot where slotname = myname;
	if not found then
	    raise exception 'x'% does not exist'', myname;
	end if;
	if rec.slotlink != blname then
	    update WSlot set slotlink = blname where slotname = myname;
	end if;
	return 0;
    end if;
    if mytype = ''IF'' then
        select into rec * from IFace where slotname = myname;
	if not found then
	    raise exception 'x'% does not exist'', myname;
	end if;
	if rec.slotlink != blname then
	    update IFace set slotlink = blname where slotname = myname;
	end if;
	return 0;
    end if;
    if mytype = ''HS'' then
        select into rec * from HSlot where slotname = myname;
	if not found then
	    raise exception 'x'% does not exist'', myname;
	end if;
	if rec.slotlink != blname then
	    update HSlot set slotlink = blname where slotname = myname;
	end if;
	return 0;
    end if;
    if mytype = ''PH'' then
        select into rec * from PHone where slotname = myname;
	if not found then
	    raise exception 'x'% does not exist'', myname;
	end if;
	if rec.slotlink != blname then
	    update PHone set slotlink = blname where slotname = myname;
	end if;
	return 0;
    end if;
    raise exception 'x'illegal slotlink beginning with %'', mytype;
end;
' language plpgsql;
CREATE FUNCTION
-- ************************************************************
-- * Support function to clear out the slotlink field if
-- * it still points to specific slot
-- ************************************************************
create function tg_slotlink_unset(bpchar, bpchar)
returns integer as '
declare
    myname	alias for $1;
    blname	alias for $2;
    mytype	char(2);
    rec		record;
begin
    mytype = substr(myname, 1, 2);
    if mytype = ''PS'' then
        select into rec * from PSlot where slotname = myname;
	if not found then
	    return 0;
	end if;
	if rec.slotlink = blname then
	    update PSlot set slotlink = '''' where slotname = myname;
	end if;
	return 0;
    end if;
    if mytype = ''WS'' then
        select into rec * from WSlot where slotname = myname;
	if not found then
	    return 0;
	end if;
	if rec.slotlink = blname then
	    update WSlot set slotlink = '''' where slotname = myname;
	end if;
	return 0;
    end if;
    if mytype = ''IF'' then
        select into rec * from IFace where slotname = myname;
	if not found then
	    return 0;
	end if;
	if rec.slotlink = blname then
	    update IFace set slotlink = '''' where slotname = myname;
	end if;
	return 0;
    end if;
    if mytype = ''HS'' then
        select into rec * from HSlot where slotname = myname;
	if not found then
	    return 0;
	end if;
	if rec.slotlink = blname then
	    update HSlot set slotlink = '''' where slotname = myname;
	end if;
	return 0;
    end if;
    if mytype = ''PH'' then
        select into rec * from PHone where slotname = myname;
	if not found then
	    return 0;
	end if;
	if rec.slotlink = blname then
	    update PHone set slotlink = '''' where slotname = myname;
	end if;
	return 0;
    end if;
end;
' language plpgsql;
CREATE FUNCTION
-- ************************************************************
-- * Describe the backside of a patchfield slot
-- ************************************************************
create function pslot_backlink_view(bpchar)
returns text as '
<<outer>>
declare
    rec		record;
    bltype	char(2);
    retval	text;
begin
    select into rec * from PSlot where slotname = $1;
    if not found then
        return '''';
    end if;
    if rec.backlink = '''' then
        return ''-'';
    end if;
    bltype = substr(rec.backlink, 1, 2);
    if bltype = ''PL'' then
        declare
	    rec		record;
	begin
	    select into rec * from PLine where slotname = "outer".rec.backlink;
	    retval = ''Phone line '' || trim(rec.phonenumber);
	    if rec.comment != '''' then
	        retval = retval || '' ('';
		retval = retval || rec.comment;
		retval = retval || '')'';
	    end if;
	    return retval;
	end;
    end if;
    if bltype = ''WS'' then
        select into rec * from WSlot where slotname = rec.backlink;
	retval = trim(rec.slotname) || '' in room '';
	retval = retval || trim(rec.roomno);
	retval = retval || '' -> '';
	return retval || wslot_slotlink_view(rec.slotname);
    end if;
    return rec.backlink;
end;
' language plpgsql;
CREATE FUNCTION
-- ************************************************************
-- * Describe the front of a patchfield slot
-- ************************************************************
create function pslot_slotlink_view(bpchar)
returns text as '
declare
    psrec	record;
    sltype	char(2);
    retval	text;
begin
    select into psrec * from PSlot where slotname = $1;
    if not found then
        return '''';
    end if;
    if psrec.slotlink = '''' then
        return ''-'';
    end if;
    sltype = substr(psrec.slotlink, 1, 2);
    if sltype = ''PS'' then
	retval = trim(psrec.slotlink) || '' -> '';
	return retval || pslot_backlink_view(psrec.slotlink);
    end if;
    if sltype = ''HS'' then
        retval = comment from Hub H, HSlot HS
			where HS.slotname = psrec.slotlink
			  and H.name = HS.hubname;
        retval = retval || '' slot '';
	retval = retval || slotno::text from HSlot
			where slotname = psrec.slotlink;
	return retval;
    end if;
    return psrec.slotlink;
end;
' language plpgsql;
CREATE FUNCTION
-- ************************************************************
-- * Describe the front of a wall connector slot
-- ************************************************************
create function wslot_slotlink_view(bpchar)
returns text as '
declare
    rec		record;
    sltype	char(2);
    retval	text;
begin
    select into rec * from WSlot where slotname = $1;
    if not found then
        return '''';
    end if;
    if rec.slotlink = '''' then
        return ''-'';
    end if;
    sltype = substr(rec.slotlink, 1, 2);
    if sltype = ''PH'' then
        select into rec * from PHone where slotname = rec.slotlink;
	retval = ''Phone '' || trim(rec.slotname);
	if rec.comment != '''' then
	    retval = retval || '' ('';
	    retval = retval || rec.comment;
	    retval = retval || '')'';
	end if;
	return retval;
    end if;
    if sltype = ''IF'' then
	declare
	    syrow	System%RowType;
	    ifrow	IFace%ROWTYPE;
        begin
	    select into ifrow * from IFace where slotname = rec.slotlink;
	    select into syrow * from System where name = ifrow.sysname;
	    retval = syrow.name || '' IF '';
	    retval = retval || ifrow.ifname;
	    if syrow.comment != '''' then
	        retval = retval || '' ('';
		retval = retval || syrow.comment;
		retval = retval || '')'';
	    end if;
	    return retval;
	end;
    end if;
    return rec.slotlink;
end;
' language plpgsql;
CREATE FUNCTION
-- ************************************************************
-- * View of a patchfield describing backside and patches
-- ************************************************************
create view Pfield_v1 as select PF.pfname, PF.slotname,
	pslot_backlink_view(PF.slotname) as backside,
	pslot_slotlink_view(PF.slotname) as patch
    from PSlot PF;
CREATE VIEW
--
-- First we build the house - so we create the rooms
--
insert into Room values ('001', 'Entrance');
INSERT 0 1
insert into Room values ('002', 'Office');
INSERT 0 1
insert into Room values ('003', 'Office');
INSERT 0 1
insert into Room values ('004', 'Technical');
INSERT 0 1
insert into Room values ('101', 'Office');
INSERT 0 1
insert into Room values ('102', 'Conference');
INSERT 0 1
insert into Room values ('103', 'Restroom');
INSERT 0 1
insert into Room values ('104', 'Technical');
INSERT 0 1
insert into Room values ('105', 'Office');
INSERT 0 1
insert into Room values ('106', 'Office');
INSERT 0 1
--
-- Second we install the wall connectors
--
insert into WSlot values ('WS.001.1a', '001', '', '');
INSERT 0 1
insert into WSlot values ('WS.001.1b', '001', '', '');
INSERT 0 1
insert into WSlot values ('WS.001.2a', '001', '', '');
INSERT 0 1
insert into WSlot values ('WS.001.2b', '001', '', '');
INSERT 0 1
insert into WSlot values ('WS.001.3a', '001', '', '');
INSERT 0 1
insert into WSlot values ('WS.001.3b', '001', '', '');
INSERT 0 1
insert into WSlot values ('WS.002.1a', '002', '', '');
INSERT 0 1
insert into WSlot values ('WS.002.1b', '002', '', '');
INSERT 0 1
insert into WSlot values ('WS.002.2a', '002', '', '');
INSERT 0 1
insert into WSlot values ('WS.002.2b', '002', '', '');
INSERT 0 1
insert into WSlot values ('WS.002.3a', '002', '', '');
INSERT 0 1
insert into WSlot values ('WS.002.3b', '002', '', '');
INSERT 0 1
insert into WSlot values ('WS.003.1a', '003', '', '');
INSERT 0 1
insert into WSlot values ('WS.003.1b', '003', '', '');
INSERT 0 1
insert into WSlot values ('WS.003.2a', '003', '', '');
INSERT 0 1
insert into WSlot values ('WS.003.2b', '003', '', '');
INSERT 0 1
insert into WSlot values ('WS.003.3a', '003', '', '');
INSERT 0 1
insert into WSlot values ('WS.003.3b', '003', '', '');
INSERT 0 1
insert into WSlot values ('WS.101.1a', '101', '', '');
INSERT 0 1
insert into WSlot values ('WS.101.1b', '101', '', '');
INSERT 0 1
insert into WSlot values ('WS.101.2a', '101', '', '');
INSERT 0 1
insert into WSlot values ('WS.101.2b', '101', '', '');
INSERT 0 1
insert into WSlot values ('WS.101.3a', '101', '', '');
INSERT 0 1
insert into WSlot values ('WS.101.3b', '101', '', '');
INSERT 0 1
insert into WSlot values ('WS.102.1a', '102', '', '');
INSERT 0 1
insert into WSlot values ('WS.102.1b', '102', '', '');
INSERT 0 1
insert into WSlot values ('WS.102.2a', '102', '', '');
INSERT 0 1
insert into WSlot values ('WS.102.2b', '102', '', '');
INSERT 0 1
insert into WSlot values ('WS.102.3a', '102', '', '');
INSERT 0 1
insert into WSlot values ('WS.102.3b', '102', '', '');
INSERT 0 1
insert into WSlot values ('WS.105.1a', '105', '', '');
INSERT 0 1
insert into WSlot values ('WS.105.1b', '105', '', '');
INSERT 0 1
insert into WSlot values ('WS.105.2a', '105', '', '');
INSERT 0 1
insert into WSlot values ('WS.105.2b', '105', '', '');
INSERT 0 1
insert into WSlot values ('WS.105.3a', '105', '', '');
INSERT 0 1
insert into WSlot values ('WS.105.3b', '105', '', '');
INSERT 0 1
insert into WSlot values ('WS.106.1a', '106', '', '');
INSERT 0 1
insert into WSlot values ('WS.106.1b', '106', '', '');
INSERT 0 1
insert into WSlot values ('WS.106.2a', '106', '', '');
INSERT 0 1
insert into WSlot values ('WS.106.2b', '106', '', '');
INSERT 0 1
insert into WSlot values ('WS.106.3a', '106', '', '');
INSERT 0 1
insert into WSlot values ('WS.106.3b', '106', '', '');
INSERT 0 1
--
-- Now create the patch fields and their slots
--
insert into PField values ('PF0_1', 'Wallslots basement');
INSERT 0 1
--
-- The cables for these will be made later, so they are unconnected for now
--
insert into PSlot values ('PS.base.a1', 'PF0_1', '', '');
INSERT 0 1
insert into PSlot values ('PS.base.a2', 'PF0_1', '', '');
INSERT 0 1
insert into PSlot values ('PS.base.a3', 'PF0_1', '', '');
INSERT 0 1
insert into PSlot values ('PS.base.a4', 'PF0_1', '', '');
INSERT 0 1
insert into PSlot values ('PS.base.a5', 'PF0_1', '', '');
INSERT 0 1
insert into PSlot values ('PS.base.a6', 'PF0_1', '', '');
INSERT 0 1
--
-- These are already wired to the wall connectors
--
insert into PSlot values ('PS.base.b1', 'PF0_1', '', 'WS.002.1a');
INSERT 0 1
insert into PSlot values ('PS.base.b2', 'PF0_1', '', 'WS.002.1b');
INSERT 0 1
insert into PSlot values ('PS.base.b3', 'PF0_1', '', 'WS.002.2a');
INSERT 0 1
insert into PSlot values ('PS.base.b4', 'PF0_1', '', 'WS.002.2b');
INSERT 0 1
insert into PSlot values ('PS.base.b5', 'PF0_1', '', 'WS.002.3a');
INSERT 0 1
insert into PSlot values ('PS.base.b6', 'PF0_1', '', 'WS.002.3b');
INSERT 0 1
insert into PSlot values ('PS.base.c1', 'PF0_1', '', 'WS.003.1a');
INSERT 0 1
insert into PSlot values ('PS.base.c2', 'PF0_1', '', 'WS.003.1b');
INSERT 0 1
insert into PSlot values ('PS.base.c3', 'PF0_1', '', 'WS.003.2a');
INSERT 0 1
insert into PSlot values ('PS.base.c4', 'PF0_1', '', 'WS.003.2b');
INSERT 0 1
insert into PSlot values ('PS.base.c5', 'PF0_1', '', 'WS.003.3a');
INSERT 0 1
insert into PSlot values ('PS.base.c6', 'PF0_1', '', 'WS.003.3b');
INSERT 0 1
--
-- This patchfield will be renamed later into PF0_2 - so its
-- slots references in pfname should follow
--
insert into PField values ('PF0_X', 'Phonelines basement');
INSERT 0 1
insert into PSlot values ('PS.base.ta1', 'PF0_X', '', '');
INSERT 0 1
insert into PSlot values ('PS.base.ta2', 'PF0_X', '', '');
INSERT 0 1
insert into PSlot values ('PS.base.ta3', 'PF0_X', '', '');
INSERT 0 1
insert into PSlot values ('PS.base.ta4', 'PF0_X', '', '');
INSERT 0 1
insert into PSlot values ('PS.base.ta5', 'PF0_X', '', '');
INSERT 0 1
insert into PSlot values ('PS.base.ta6', 'PF0_X', '', '');
INSERT 0 1
insert into PSlot values ('PS.base.tb1', 'PF0_X', '', '');
INSERT 0 1
insert into PSlot values ('PS.base.tb2', 'PF0_X', '', '');
INSERT 0 1
insert into PSlot values ('PS.base.tb3', 'PF0_X', '', '');
INSERT 0 1
insert into PSlot values ('PS.base.tb4', 'PF0_X', '', '');
INSERT 0 1
insert into PSlot values ('PS.base.tb5', 'PF0_X', '', '');
INSERT 0 1
insert into PSlot values ('PS.base.tb6', 'PF0_X', '', '');
INSERT 0 1
insert into PField values ('PF1_1', 'Wallslots first floor');
INSERT 0 1
insert into PSlot values ('PS.first.a1', 'PF1_1', '', 'WS.101.1a');
INSERT 0 1
insert into PSlot values ('PS.first.a2', 'PF1_1', '', 'WS.101.1b');
INSERT 0 1
insert into PSlot values ('PS.first.a3', 'PF1_1', '', 'WS.101.2a');
INSERT 0 1
insert into PSlot values ('PS.first.a4', 'PF1_1', '', 'WS.101.2b');
INSERT 0 1
insert into PSlot values ('PS.first.a5', 'PF1_1', '', 'WS.101.3a');
INSERT 0 1
insert into PSlot values ('PS.first.a6', 'PF1_1', '', 'WS.101.3b');
INSERT 0 1
insert into PSlot values ('PS.first.b1', 'PF1_1', '', 'WS.102.1a');
INSERT 0 1
insert into PSlot values ('PS.first.b2', 'PF1_1', '', 'WS.102.1b');
INSERT 0 1
insert into PSlot values ('PS.first.b3', 'PF1_1', '', 'WS.102.2a');
INSERT 0 1
insert into PSlot values ('PS.first.b4', 'PF1_1', '', 'WS.102.2b');
INSERT 0 1
insert into PSlot values ('PS.first.b5', 'PF1_1', '', 'WS.102.3a');
INSERT 0 1
insert into PSlot values ('PS.first.b6', 'PF1_1', '', 'WS.102.3b');
INSERT 0 1
insert into PSlot values ('PS.first.c1', 'PF1_1', '', 'WS.105.1a');
INSERT 0 1
insert into PSlot values ('PS.first.c2', 'PF1_1', '', 'WS.105.1b');
INSERT 0 1
insert into PSlot values ('PS.first.c3', 'PF1_1', '', 'WS.105.2a');
INSERT 0 1
insert into PSlot values ('PS.first.c4', 'PF1_1', '', 'WS.105.2b');
INSERT 0 1
insert into PSlot values ('PS.first.c5', 'PF1_1', '', 'WS.105.3a');
INSERT 0 1
insert into PSlot values ('PS.first.c6', 'PF1_1', '', 'WS.105.3b');
INSERT 0 1
insert into PSlot values ('PS.first.d1', 'PF1_1', '', 'WS.106.1a');
INSERT 0 1
insert into PSlot values ('PS.first.d2', 'PF1_1', '', 'WS.106.1b');
INSERT 0 1
insert into PSlot values ('PS.first.d3', 'PF1_1', '', 'WS.106.2a');
INSERT 0 1
insert into PSlot values ('PS.first.d4', 'PF1_1', '', 'WS.106.2b');
INSERT 0 1
insert into PSlot values ('PS.first.d5', 'PF1_1', '', 'WS.106.3a');
INSERT 0 1
insert into PSlot values ('PS.first.d6', 'PF1_1', '', 'WS.106.3b');
INSERT 0 1
--
-- Now we wire the wall connectors 1a-2a in room 001 to the
-- patchfield. In the second update we make an error, and
-- correct it after
--
update PSlot set backlink = 'WS.001.1a' where slotname = 'PS.base.a1';
UPDATE 1
update PSlot set backlink = 'WS.001.1b' where slotname = 'PS.base.a3';
UPDATE 1
select * from WSlot where roomno = '001' order by slotname;
       slotname       |  roomno  |       slotlink       |       backlink       
----------------------+----------+----------------------+----------------------
 WS.001.1a            | 001      |                      |                     
 WS.001.1b            | 001      |                      |                     
 WS.001.2a            | 001      |                      |                     
 WS.001.2b            | 001      |                      |                     
 WS.001.3a            | 001      |                      |                     
 WS.001.3b            | 001      |                      |                     
(6 rows)

select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
       slotname       | pfname |       slotlink       |       backlink       
----------------------+--------+----------------------+----------------------
 PS.base.a1           | PF0_1  |                      | WS.001.1a           
 PS.base.a2           | PF0_1  |                      |                     
 PS.base.a3           | PF0_1  |                      | WS.001.1b           
 PS.base.a4           | PF0_1  |                      |                     
 PS.base.a5           | PF0_1  |                      |                     
 PS.base.a6           | PF0_1  |                      |                     
(6 rows)

update PSlot set backlink = 'WS.001.2a' where slotname = 'PS.base.a3';
UPDATE 1
select * from WSlot where roomno = '001' order by slotname;
       slotname       |  roomno  |       slotlink       |       backlink       
----------------------+----------+----------------------+----------------------
 WS.001.1a            | 001      |                      |                     
 WS.001.1b            | 001      |                      |                     
 WS.001.2a            | 001      |                      |                     
 WS.001.2b            | 001      |                      |                     
 WS.001.3a            | 001      |                      |                     
 WS.001.3b            | 001      |                      |                     
(6 rows)

select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
       slotname       | pfname |       slotlink       |       backlink       
----------------------+--------+----------------------+----------------------
 PS.base.a1           | PF0_1  |                      | WS.001.1a           
 PS.base.a2           | PF0_1  |                      |                     
 PS.base.a3           | PF0_1  |                      | WS.001.2a           
 PS.base.a4           | PF0_1  |                      |                     
 PS.base.a5           | PF0_1  |                      |                     
 PS.base.a6           | PF0_1  |                      |                     
(6 rows)

update PSlot set backlink = 'WS.001.1b' where slotname = 'PS.base.a2';
UPDATE 1
select * from WSlot where roomno = '001' order by slotname;
       slotname       |  roomno  |       slotlink       |       backlink       
----------------------+----------+----------------------+----------------------
 WS.001.1a            | 001      |                      |                     
 WS.001.1b            | 001      |                      |                     
 WS.001.2a            | 001      |                      |                     
 WS.001.2b            | 001      |                      |                     
 WS.001.3a            | 001      |                      |                     
 WS.001.3b            | 001      |                      |                     
(6 rows)

select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
       slotname       | pfname |       slotlink       |       backlink       
----------------------+--------+----------------------+----------------------
 PS.base.a1           | PF0_1  |                      | WS.001.1a           
 PS.base.a2           | PF0_1  |                      | WS.001.1b           
 PS.base.a3           | PF0_1  |                      | WS.001.2a           
 PS.base.a4           | PF0_1  |                      |                     
 PS.base.a5           | PF0_1  |                      |                     
 PS.base.a6           | PF0_1  |                      |                     
(6 rows)

--
-- Same procedure for 2b-3b but this time updating the WSlot instead
-- of the PSlot. Due to the triggers the result is the same:
-- WSlot and corresponding PSlot point to each other.
--
update WSlot set backlink = 'PS.base.a4' where slotname = 'WS.001.2b';
UPDATE 1
update WSlot set backlink = 'PS.base.a6' where slotname = 'WS.001.3a';
UPDATE 1
select * from WSlot where roomno = '001' order by slotname;
       slotname       |  roomno  |       slotlink       |       backlink       
----------------------+----------+----------------------+----------------------
 WS.001.1a            | 001      |                      |                     
 WS.001.1b            | 001      |                      |                     
 WS.001.2a            | 001      |                      |                     
 WS.001.2b            | 001      |                      | PS.base.a4          
 WS.001.3a            | 001      |                      | PS.base.a6          
 WS.001.3b            | 001      |                      |                     
(6 rows)

select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
       slotname       | pfname |       slotlink       |       backlink       
----------------------+--------+----------------------+----------------------
 PS.base.a1           | PF0_1  |                      | WS.001.1a           
 PS.base.a2           | PF0_1  |                      | WS.001.1b           
 PS.base.a3           | PF0_1  |                      | WS.001.2a           
 PS.base.a4           | PF0_1  |                      |                     
 PS.base.a5           | PF0_1  |                      |                     
 PS.base.a6           | PF0_1  |                      |                     
(6 rows)

update WSlot set backlink = 'PS.base.a6' where slotname = 'WS.001.3b';
UPDATE 1
select * from WSlot where roomno = '001' order by slotname;
       slotname       |  roomno  |       slotlink       |       backlink       
----------------------+----------+----------------------+----------------------
 WS.001.1a            | 001      |                      |                     
 WS.001.1b            | 001      |                      |                     
 WS.001.2a            | 001      |                      |                     
 WS.001.2b            | 001      |                      | PS.base.a4          
 WS.001.3a            | 001      |                      | PS.base.a6          
 WS.001.3b            | 001      |                      | PS.base.a6          
(6 rows)

select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
       slotname       | pfname |       slotlink       |       backlink       
----------------------+--------+----------------------+----------------------
 PS.base.a1           | PF0_1  |                      | WS.001.1a           
 PS.base.a2           | PF0_1  |                      | WS.001.1b           
 PS.base.a3           | PF0_1  |                      | WS.001.2a           
 PS.base.a4           | PF0_1  |                      |                     
 PS.base.a5           | PF0_1  |                      |                     
 PS.base.a6           | PF0_1  |                      |                     
(6 rows)

update WSlot set backlink = 'PS.base.a5' where slotname = 'WS.001.3a';
UPDATE 1
select * from WSlot where roomno = '001' order by slotname;
       slotname       |  roomno  |       slotlink       |       backlink       
----------------------+----------+----------------------+----------------------
 WS.001.1a            | 001      |                      |                     
 WS.001.1b            | 001      |                      |                     
 WS.001.2a            | 001      |                      |                     
 WS.001.2b            | 001      |                      | PS.base.a4          
 WS.001.3a            | 001      |                      | PS.base.a5          
 WS.001.3b            | 001      |                      | PS.base.a6          
(6 rows)

select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
       slotname       | pfname |       slotlink       |       backlink       
----------------------+--------+----------------------+----------------------
 PS.base.a1           | PF0_1  |                      | WS.001.1a           
 PS.base.a2           | PF0_1  |                      | WS.001.1b           
 PS.base.a3           | PF0_1  |                      | WS.001.2a           
 PS.base.a4           | PF0_1  |                      |                     
 PS.base.a5           | PF0_1  |                      |                     
 PS.base.a6           | PF0_1  |                      |                     
(6 rows)

insert into PField values ('PF1_2', 'Phonelines first floor');
INSERT 0 1
insert into PSlot values ('PS.first.ta1', 'PF1_2', '', '');
INSERT 0 1
insert into PSlot values ('PS.first.ta2', 'PF1_2', '', '');
INSERT 0 1
insert into PSlot values ('PS.first.ta3', 'PF1_2', '', '');
INSERT 0 1
insert into PSlot values ('PS.first.ta4', 'PF1_2', '', '');
INSERT 0 1
insert into PSlot values ('PS.first.ta5', 'PF1_2', '', '');
INSERT 0 1
insert into PSlot values ('PS.first.ta6', 'PF1_2', '', '');
INSERT 0 1
insert into PSlot values ('PS.first.tb1', 'PF1_2', '', '');
INSERT 0 1
insert into PSlot values ('PS.first.tb2', 'PF1_2', '', '');
INSERT 0 1
insert into PSlot values ('PS.first.tb3', 'PF1_2', '', '');
INSERT 0 1
insert into PSlot values ('PS.first.tb4', 'PF1_2', '', '');
INSERT 0 1
insert into PSlot values ('PS.first.tb5', 'PF1_2', '', '');
INSERT 0 1
insert into PSlot values ('PS.first.tb6', 'PF1_2', '', '');
INSERT 0 1
--
-- Fix the wrong name for patchfield PF0_2
--
update PField set name = 'PF0_2' where name = 'PF0_X';
UPDATE 1
select * from PSlot order by slotname;
       slotname       | pfname |       slotlink       |       backlink       
----------------------+--------+----------------------+----------------------
 PS.base.a1           | PF0_1  |                      | WS.001.1a           
 PS.base.a2           | PF0_1  |                      | WS.001.1b           
 PS.base.a3           | PF0_1  |                      | WS.001.2a           
 PS.base.a4           | PF0_1  |                      |                     
 PS.base.a5           | PF0_1  |                      |                     
 PS.base.a6           | PF0_1  |                      |                     
 PS.base.b1           | PF0_1  |                      | WS.002.1a           
 PS.base.b2           | PF0_1  |                      | WS.002.1b           
 PS.base.b3           | PF0_1  |                      | WS.002.2a           
 PS.base.b4           | PF0_1  |                      | WS.002.2b           
 PS.base.b5           | PF0_1  |                      | WS.002.3a           
 PS.base.b6           | PF0_1  |                      | WS.002.3b           
 PS.base.c1           | PF0_1  |                      | WS.003.1a           
 PS.base.c2           | PF0_1  |                      | WS.003.1b           
 PS.base.c3           | PF0_1  |                      | WS.003.2a           
 PS.base.c4           | PF0_1  |                      | WS.003.2b           
 PS.base.c5           | PF0_1  |                      | WS.003.3a           
 PS.base.c6           | PF0_1  |                      | WS.003.3b           
 PS.base.ta1          | PF0_X  |                      |                     
 PS.base.ta2          | PF0_X  |                      |                     
 PS.base.ta3          | PF0_X  |                      |                     
 PS.base.ta4          | PF0_X  |                      |                     
 PS.base.ta5          | PF0_X  |                      |                     
 PS.base.ta6          | PF0_X  |                      |                     
 PS.base.tb1          | PF0_X  |                      |                     
 PS.base.tb2          | PF0_X  |                      |                     
 PS.base.tb3          | PF0_X  |                      |                     
 PS.base.tb4          | PF0_X  |                      |                     
 PS.base.tb5          | PF0_X  |                      |                     
 PS.base.tb6          | PF0_X  |                      |                     
 PS.first.a1          | PF1_1  |                      | WS.101.1a           
 PS.first.a2          | PF1_1  |                      | WS.101.1b           
 PS.first.a3          | PF1_1  |                      | WS.101.2a           
 PS.first.a4          | PF1_1  |                      | WS.101.2b           
 PS.first.a5          | PF1_1  |                      | WS.101.3a           
 PS.first.a6          | PF1_1  |                      | WS.101.3b           
 PS.first.b1          | PF1_1  |                      | WS.102.1a           
 PS.first.b2          | PF1_1  |                      | WS.102.1b           
 PS.first.b3          | PF1_1  |                      | WS.102.2a           
 PS.first.b4          | PF1_1  |                      | WS.102.2b           
 PS.first.b5          | PF1_1  |                      | WS.102.3a           
 PS.first.b6          | PF1_1  |                      | WS.102.3b           
 PS.first.c1          | PF1_1  |                      | WS.105.1a           
 PS.first.c2          | PF1_1  |                      | WS.105.1b           
 PS.first.c3          | PF1_1  |                      | WS.105.2a           
 PS.first.c4          | PF1_1  |                      | WS.105.2b           
 PS.first.c5          | PF1_1  |                      | WS.105.3a           
 PS.first.c6          | PF1_1  |                      | WS.105.3b           
 PS.first.d1          | PF1_1  |                      | WS.106.1a           
 PS.first.d2          | PF1_1  |                      | WS.106.1b           
 PS.first.d3          | PF1_1  |                      | WS.106.2a           
 PS.first.d4          | PF1_1  |                      | WS.106.2b           
 PS.first.d5          | PF1_1  |                      | WS.106.3a           
 PS.first.d6          | PF1_1  |                      | WS.106.3b           
 PS.first.ta1         | PF1_2  |                      |                     
 PS.first.ta2         | PF1_2  |                      |                     
 PS.first.ta3         | PF1_2  |                      |                     
 PS.first.ta4         | PF1_2  |                      |                     
 PS.first.ta5         | PF1_2  |                      |                     
 PS.first.ta6         | PF1_2  |                      |                     
 PS.first.tb1         | PF1_2  |                      |                     
 PS.first.tb2         | PF1_2  |                      |                     
 PS.first.tb3         | PF1_2  |                      |                     
 PS.first.tb4         | PF1_2  |                      |                     
 PS.first.tb5         | PF1_2  |                      |                     
 PS.first.tb6         | PF1_2  |                      |                     
(66 rows)

select * from WSlot order by slotname;
       slotname       |  roomno  |       slotlink       |       backlink       
----------------------+----------+----------------------+----------------------
 WS.001.1a            | 001      |                      |                     
 WS.001.1b            | 001      |                      |                     
 WS.001.2a            | 001      |                      |                     
 WS.001.2b            | 001      |                      | PS.base.a4          
 WS.001.3a            | 001      |                      | PS.base.a5          
 WS.001.3b            | 001      |                      | PS.base.a6          
 WS.002.1a            | 002      |                      |                     
 WS.002.1b            | 002      |                      |                     
 WS.002.2a            | 002      |                      |                     
 WS.002.2b            | 002      |                      |                     
 WS.002.3a            | 002      |                      |                     
 WS.002.3b            | 002      |                      |                     
 WS.003.1a            | 003      |                      |                     
 WS.003.1b            | 003      |                      |                     
 WS.003.2a            | 003      |                      |                     
 WS.003.2b            | 003      |                      |                     
 WS.003.3a            | 003      |                      |                     
 WS.003.3b            | 003      |                      |                     
 WS.101.1a            | 101      |                      |                     
 WS.101.1b            | 101      |                      |                     
 WS.101.2a            | 101      |                      |                     
 WS.101.2b            | 101      |                      |                     
 WS.101.3a            | 101      |                      |                     
 WS.101.3b            | 101      |                      |                     
 WS.102.1a            | 102      |                      |                     
 WS.102.1b            | 102      |                      |                     
 WS.102.2a            | 102      |                      |                     
 WS.102.2b            | 102      |                      |                     
 WS.102.3a            | 102      |                      |                     
 WS.102.3b            | 102      |                      |                     
 WS.105.1a            | 105      |                      |                     
 WS.105.1b            | 105      |                      |                     
 WS.105.2a            | 105      |                      |                     
 WS.105.2b            | 105      |                      |                     
 WS.105.3a            | 105      |                      |                     
 WS.105.3b            | 105      |                      |                     
 WS.106.1a            | 106      |                      |                     
 WS.106.1b            | 106      |                      |                     
 WS.106.2a            | 106      |                      |                     
 WS.106.2b            | 106      |                      |                     
 WS.106.3a            | 106      |                      |                     
 WS.106.3b            | 106      |                      |                     
(42 rows)

--
-- Install the central phone system and create the phone numbers.
-- They are wired on insert to the patchfields. Again the
-- triggers automatically tell the PSlots to update their
-- backlink field.
--
insert into PLine values ('PL.001', '-0', 'Central call', 'PS.base.ta1');
INSERT 0 1
insert into PLine values ('PL.002', '-101', '', 'PS.base.ta2');
INSERT 0 1
insert into PLine values ('PL.003', '-102', '', 'PS.base.ta3');
INSERT 0 1
insert into PLine values ('PL.004', '-103', '', 'PS.base.ta5');
INSERT 0 1
insert into PLine values ('PL.005', '-104', '', 'PS.base.ta6');
INSERT 0 1
insert into PLine values ('PL.006', '-106', '', 'PS.base.tb2');
INSERT 0 1
insert into PLine values ('PL.007', '-108', '', 'PS.base.tb3');
INSERT 0 1
insert into PLine values ('PL.008', '-109', '', 'PS.base.tb4');
INSERT 0 1
insert into PLine values ('PL.009', '-121', '', 'PS.base.tb5');
INSERT 0 1
insert into PLine values ('PL.010', '-122', '', 'PS.base.tb6');
INSERT 0 1
insert into PLine values ('PL.015', '-134', '', 'PS.first.ta1');
INSERT 0 1
insert into PLine values ('PL.016', '-137', '', 'PS.first.ta3');
INSERT 0 1
insert into PLine values ('PL.017', '-139', '', 'PS.first.ta4');
INSERT 0 1
insert into PLine values ('PL.018', '-362', '', 'PS.first.tb1');
INSERT 0 1
insert into PLine values ('PL.019', '-363', '', 'PS.first.tb2');
INSERT 0 1
insert into PLine values ('PL.020', '-364', '', 'PS.first.tb3');
INSERT 0 1
insert into PLine values ('PL.021', '-365', '', 'PS.first.tb5');
INSERT 0 1
insert into PLine values ('PL.022', '-367', '', 'PS.first.tb6');
INSERT 0 1
insert into PLine values ('PL.028', '-501', 'Fax entrance', 'PS.base.ta2');
INSERT 0 1
insert into PLine values ('PL.029', '-502', 'Fax first floor', 'PS.first.ta1');
INSERT 0 1
--
-- Buy some phones, plug them into the wall and patch the
-- phone lines to the corresponding patchfield slots.
--
insert into PHone values ('PH.hc001', 'Hicom standard', 'WS.001.1a');
INSERT 0 1
update PSlot set slotlink = 'PS.base.ta1' where slotname = 'PS.base.a1';
UPDATE 1
insert into PHone values ('PH.hc002', 'Hicom standard', 'WS.002.1a');
INSERT 0 1
update PSlot set slotlink = 'PS.base.ta5' where slotname = 'PS.base.b1';
UPDATE 1
insert into PHone values ('PH.hc003', 'Hicom standard', 'WS.002.2a');
INSERT 0 1
update PSlot set slotlink = 'PS.base.tb2' where slotname = 'PS.base.b3';
UPDATE 1
insert into PHone values ('PH.fax001', 'Canon fax', 'WS.001.2a');
INSERT 0 1
update PSlot set slotlink = 'PS.base.ta2' where slotname = 'PS.base.a3';
UPDATE 1
--
-- Install a hub at one of the patchfields, plug a computers
-- ethernet interface into the wall and patch it to the hub.
--
insert into Hub values ('base.hub1', 'Patchfield PF0_1 hub', 16);
INSERT 0 1
insert into System values ('orion', 'PC');
INSERT 0 1
insert into IFace values ('IF', 'orion', 'eth0', 'WS.002.1b');
INSERT 0 1
update PSlot set slotlink = 'HS.base.hub1.1' where slotname = 'PS.base.b2';
UPDATE 1
--
-- Now we take a look at the patchfield
--
--select * from PField_v1 where pfname = 'PF0_1' order by slotname;
--select * from PField_v1 where pfname = 'PF0_2' order by slotname;
--
-- Finally we want errors
--
insert into PField values ('PF1_1', 'should fail due to unique index');
psql:sql/plpgsql.sql:665: ERROR:  Kunlun-db: MySQL storage node (1, 1) returned error: 1062, Duplicate entry 'PF1_1' for key 'pfield.pfield_name'.
update PSlot set backlink = 'WS.not.there' where slotname = 'PS.base.a1';
UPDATE 1
update PSlot set backlink = 'XX.illegal' where slotname = 'PS.base.a1';
UPDATE 1
update PSlot set slotlink = 'PS.not.there' where slotname = 'PS.base.a1';
UPDATE 1
update PSlot set slotlink = 'XX.illegal' where slotname = 'PS.base.a1';
UPDATE 1
insert into HSlot values ('HS', 'base.hub1', 1, '');
INSERT 0 1
insert into HSlot values ('HS', 'base.hub1', 20, '');
psql:sql/plpgsql.sql:671: ERROR:  Kunlun-db: MySQL storage node (1, 1) returned error: 1062, Duplicate entry 'HS' for key 'hslot.hslot_name'.
delete from HSlot;
DELETE 1
insert into IFace values ('IF', 'notthere', 'eth0', '');
psql:sql/plpgsql.sql:673: ERROR:  Kunlun-db: MySQL storage node (1, 1) returned error: 1062, Duplicate entry 'IF' for key 'iface.iface_name'.
insert into IFace values ('IF', 'orion', 'ethernet_interface_name_too_long', '');
psql:sql/plpgsql.sql:674: ERROR:  Kunlun-db: MySQL storage node (1, 1) returned error: 1062, Duplicate entry 'IF' for key 'iface.iface_name'.
--
-- The following tests are unrelated to the scenario outlined above;
-- they merely exercise specific parts of PL/pgSQL
--
--
-- Test recursion, per bug report 7-Sep-01
--
CREATE FUNCTION recursion_test(int,int) RETURNS text AS '
DECLARE rslt text;
BEGIN
    IF $1 <= 0 THEN
        rslt = CAST($2 AS TEXT);
    ELSE
        rslt = CAST($1 AS TEXT) || '','' || recursion_test($1 - 1, $2);
    END IF;
    RETURN rslt;
END;' LANGUAGE plpgsql;
CREATE FUNCTION
SELECT recursion_test(4,3);
 recursion_test 
----------------
 4,3,2,1,3
(1 row)

--select * from test_ret_set_scalar(1,10);
create function test_ret_set_rec_dyn(int) returns setof record as '
DECLARE
	retval RECORD;
BEGIN
	IF $1 > 10 THEN
		SELECT INTO retval 5, 10, 15;
		RETURN NEXT retval;
		RETURN NEXT retval;
	ELSE
		SELECT INTO retval 50, 5::numeric, ''xxx''::text;
		RETURN NEXT retval;
		RETURN NEXT retval;
	END IF;
	RETURN;
END;' language plpgsql;
CREATE FUNCTION
SELECT * FROM test_ret_set_rec_dyn(1500) AS (a int, b int, c int);
 a | b  | c  
---+----+----
 5 | 10 | 15
 5 | 10 | 15
(2 rows)

SELECT * FROM test_ret_set_rec_dyn(5) AS (a int, b numeric, c text);
 a  | b |  c  
----+---+-----
 50 | 5 | xxx
 50 | 5 | xxx
(2 rows)

create function test_ret_rec_dyn(int) returns record as '
DECLARE
	retval RECORD;
BEGIN
	IF $1 > 10 THEN
		SELECT INTO retval 5, 10, 15;
		RETURN retval;
	ELSE
		SELECT INTO retval 50, 5::numeric, ''xxx''::text;
		RETURN retval;
	END IF;
END;' language plpgsql;
CREATE FUNCTION
SELECT * FROM test_ret_rec_dyn(1500) AS (a int, b int, c int);
 a | b  | c  
---+----+----
 5 | 10 | 15
(1 row)

SELECT * FROM test_ret_rec_dyn(5) AS (a int, b numeric, c text);
 a  | b |  c  
----+---+-----
 50 | 5 | xxx
(1 row)

--
-- Test handling of OUT parameters, including polymorphic cases.
-- Note that RETURN is optional with OUT params; we try both ways.
--
-- wrong way to do it:
create function f1(in i int, out j int) returns int as $$
begin
  return i+1;
end$$ language plpgsql;
psql:sql/plpgsql.sql:745: ERROR:  RETURN cannot have a parameter in function with OUT parameters
LINE 3:   return i+1;
                 ^
create function f1(in i int, out j int) as $$
begin
  j = i+1;
  return;
end$$ language plpgsql;
CREATE FUNCTION
select f1(42);
 f1 
----
 43
(1 row)

select * from f1(42);
 j  
----
 43
(1 row)

create or replace function f1(inout i int) as $$
begin
  i = i+1;
end$$ language plpgsql;
CREATE FUNCTION
select f1(42);
 f1 
----
 43
(1 row)

select * from f1(42);
 i  
----
 43
(1 row)

drop function f1(int);
DROP FUNCTION
create function f1(in i int, out j int) returns setof int as $$
begin
  j = i+1;
  return next;
  j = i+2;
  return next;
  return;
end$$ language plpgsql;
CREATE FUNCTION
select * from f1(42);
 j  
----
 43
 44
(2 rows)

drop function f1(int);
DROP FUNCTION
create function f1(in i int, out j int, out k text) as $$
begin
  j = i;
  j = j+1;
  k = 'foo';
end$$ language plpgsql;
CREATE FUNCTION
select f1(42);
    f1    
----------
 (43,foo)
(1 row)

select * from f1(42);
 j  |  k  
----+-----
 43 | foo
(1 row)

drop function f1(int);
DROP FUNCTION
create function f1(in i int, out j int, out k text) returns setof record as $$
begin
  j = i+1;
  k = 'foo';
  return next;
  j = j+1;
  k = 'foot';
  return next;
end$$ language plpgsql;
CREATE FUNCTION
select * from f1(42);
 j  |  k   
----+------
 43 | foo
 44 | foot
(2 rows)

drop function f1(int);
DROP FUNCTION
create function duplic(in i anyelement, out j anyelement, out k anyarray) as $$
begin
  j = i;
  k = array[j,j];
  return;
end$$ language plpgsql;
CREATE FUNCTION
select * from duplic(42);
 j  |    k    
----+---------
 42 | {42,42}
(1 row)

select * from duplic('foo'::text);
  j  |     k     
-----+-----------
 foo | {foo,foo}
(1 row)

drop function duplic(anyelement);
DROP FUNCTION
--
-- test PERFORM
--
create table perform_test (
	a	INT,
	b	INT
);
CREATE TABLE
create function perform_simple_func(int) returns boolean as '
BEGIN
	IF $1 < 20 THEN
		INSERT INTO perform_test VALUES ($1, $1 + 10);
		RETURN TRUE;
	ELSE
		RETURN FALSE;
	END IF;
END;' language plpgsql;
CREATE FUNCTION
create function perform_test_func() returns void as '
BEGIN
	IF FOUND then
		INSERT INTO perform_test VALUES (100, 100);
	END IF;

	PERFORM perform_simple_func(5);

	IF FOUND then
		INSERT INTO perform_test VALUES (100, 100);
	END IF;

	PERFORM perform_simple_func(50);

	IF FOUND then
		INSERT INTO perform_test VALUES (100, 100);
	END IF;

	RETURN;
END;' language plpgsql;
CREATE FUNCTION
SELECT perform_test_func();
 perform_test_func 
-------------------
 
(1 row)

SELECT * FROM perform_test;
  a  |  b  
-----+-----
   5 |  15
 100 | 100
 100 | 100
(3 rows)

drop table perform_test;
DROP TABLE
--
-- Test error trapping
--
create function trap_zero_divide(int) returns int as $$
declare x int;
	sx smallint;
begin
	begin	-- start a subtransaction
		raise notice 'should see this';
		x = 100 / $1;
		raise notice 'should see this only if % <> 0', $1;
		sx = $1;
		raise notice 'should see this only if % fits in smallint', $1;
		if $1 < 0 then
			raise exception '% is less than zero', $1;
		end if;
	exception
		when division_by_zero then
			raise notice 'caught division_by_zero';
			x = -1;
		when NUMERIC_VALUE_OUT_OF_RANGE then
			raise notice 'caught numeric_value_out_of_range';
			x = -2;
	end;
	return x;
end$$ language plpgsql;
CREATE FUNCTION
select trap_zero_divide(50);
psql:sql/plpgsql.sql:890: NOTICE:  should see this
psql:sql/plpgsql.sql:890: NOTICE:  should see this only if 50 <> 0
psql:sql/plpgsql.sql:890: NOTICE:  should see this only if 50 fits in smallint
 trap_zero_divide 
------------------
                2
(1 row)

select trap_zero_divide(0);
psql:sql/plpgsql.sql:891: NOTICE:  should see this
psql:sql/plpgsql.sql:891: NOTICE:  caught division_by_zero
 trap_zero_divide 
------------------
               -1
(1 row)

select trap_zero_divide(100000);
psql:sql/plpgsql.sql:892: NOTICE:  should see this
psql:sql/plpgsql.sql:892: NOTICE:  should see this only if 100000 <> 0
psql:sql/plpgsql.sql:892: NOTICE:  caught numeric_value_out_of_range
 trap_zero_divide 
------------------
               -2
(1 row)

select trap_zero_divide(-100);
psql:sql/plpgsql.sql:893: NOTICE:  should see this
psql:sql/plpgsql.sql:893: NOTICE:  should see this only if -100 <> 0
psql:sql/plpgsql.sql:893: NOTICE:  should see this only if -100 fits in smallint
psql:sql/plpgsql.sql:893: ERROR:  -100 is less than zero
CONTEXT:  PL/pgSQL function trap_zero_divide(integer) line 12 at RAISE
create function trap_matching_test(int) returns int as $$
declare x int;
	sx smallint;
	y int;
begin
	begin	-- start a subtransaction
		x = 100 / $1;
		sx = $1;
		select into y unique1 from tenk1 where unique2 =
			(select unique2 from tenk1 b where ten = $1);
	exception
		when data_exception then  -- category match
			raise notice 'caught data_exception';
			x = -1;
		when NUMERIC_VALUE_OUT_OF_RANGE OR CARDINALITY_VIOLATION then
			raise notice 'caught numeric_value_out_of_range or cardinality_violation';
			x = -2;
	end;
	return x;
end$$ language plpgsql;
CREATE FUNCTION
select trap_matching_test(50);
 trap_matching_test 
--------------------
                  2
(1 row)

select trap_matching_test(0);
psql:sql/plpgsql.sql:917: NOTICE:  caught data_exception
 trap_matching_test 
--------------------
                 -1
(1 row)

select trap_matching_test(100000);
psql:sql/plpgsql.sql:918: NOTICE:  caught data_exception
 trap_matching_test 
--------------------
                 -1
(1 row)

select trap_matching_test(1);
psql:sql/plpgsql.sql:919: NOTICE:  caught numeric_value_out_of_range or cardinality_violation
 trap_matching_test 
--------------------
                 -2
(1 row)

create temp table foo (f1 int);
CREATE TABLE
create function subxact_rollback_semantics() returns int as $$
declare x int;
begin
  x = 1;
  insert into foo values(x);
  begin
    x = x + 1;
    insert into foo values(x);
    raise exception 'inner';
  exception
    when others then
      x = x * 10;
  end;
  insert into foo values(x);
  return x;
end$$ language plpgsql;
CREATE FUNCTION
select subxact_rollback_semantics();
 subxact_rollback_semantics 
----------------------------
                         20
(1 row)

select * from foo;
 f1 
----
  1
 20
(2 rows)

drop table foo;
DROP TABLE
create function trap_timeout() returns void as $$
begin
  declare x int;
  begin
    -- we assume this will take longer than 2 seconds:
    select count(*) into x from tenk1 a, tenk1 b, tenk1 c;
  exception
    when others then
      raise notice 'caught others?';
    when query_canceled then
      raise notice 'nyeah nyeah, can''t stop me';
  end;
  -- Abort transaction to abandon the statement_timeout setting.  Otherwise,
  -- the next top-level statement would be vulnerable to the timeout.
  raise exception 'end of function';
end$$ language plpgsql;
CREATE FUNCTION
begin;
BEGIN
set statement_timeout to 2000;
SET
select trap_timeout();
psql:sql/plpgsql.sql:963: NOTICE:  nyeah nyeah, can't stop me
psql:sql/plpgsql.sql:963: ERROR:  end of function
CONTEXT:  PL/pgSQL function trap_timeout() line 15 at RAISE
rollback;
ROLLBACK
-- Test for pass-by-ref values being stored in proper context
create function test_variable_storage() returns text as $$
declare x text;
begin
  x = '1234';
  begin
    x = x || '5678';
    -- force error inside subtransaction SPI context
    perform trap_zero_divide(-100);
  exception
    when others then
      x = x || '9012';
  end;
  return x;
end$$ language plpgsql;
CREATE FUNCTION
select test_variable_storage();
psql:sql/plpgsql.sql:982: NOTICE:  should see this
psql:sql/plpgsql.sql:982: NOTICE:  should see this only if -100 <> 0
psql:sql/plpgsql.sql:982: NOTICE:  should see this only if -100 fits in smallint
 test_variable_storage 
-----------------------
 123456789012
(1 row)

--
-- test foreign key error trapping
--
create temp table master(f1 int primary key);
CREATE TABLE
--create temp table slave(f1 int references master deferrable);
insert into master values(1);
INSERT 0 1
insert into slave values(1);
psql:sql/plpgsql.sql:993: ERROR:  relation "slave" does not exist
LINE 1: insert into slave values(1);
                    ^
insert into slave values(2);	-- fails
psql:sql/plpgsql.sql:994: ERROR:  relation "slave" does not exist
LINE 1: insert into slave values(2);
                    ^
create function trap_foreign_key(int) returns int as $$
begin
	begin	-- start a subtransaction
		insert into slave values($1);
	exception
		when foreign_key_violation then
			raise notice 'caught foreign_key_violation';
			return 0;
	end;
	return 1;
end$$ language plpgsql;
CREATE FUNCTION
create function trap_foreign_key_2() returns int as $$
begin
	begin	-- start a subtransaction
		set constraints all immediate;
	exception
		when foreign_key_violation then
			raise notice 'caught foreign_key_violation';
			return 0;
	end;
	return 1;
end$$ language plpgsql;
CREATE FUNCTION
select trap_foreign_key(1);
psql:sql/plpgsql.sql:1020: ERROR:  relation "slave" does not exist
LINE 1: insert into slave values($1)
                    ^
QUERY:  insert into slave values($1)
CONTEXT:  PL/pgSQL function trap_foreign_key(integer) line 4 at SQL statement
select trap_foreign_key(2);	-- detects FK violation
psql:sql/plpgsql.sql:1021: ERROR:  relation "slave" does not exist
LINE 1: insert into slave values($1)
                    ^
QUERY:  insert into slave values($1)
CONTEXT:  PL/pgSQL function trap_foreign_key(integer) line 4 at SQL statement
begin;
BEGIN
  set constraints all deferred;
SET CONSTRAINTS
  select trap_foreign_key(2);	-- should not detect FK violation
psql:sql/plpgsql.sql:1025: ERROR:  relation "slave" does not exist
LINE 1: insert into slave values($1)
                    ^
QUERY:  insert into slave values($1)
CONTEXT:  PL/pgSQL function trap_foreign_key(integer) line 4 at SQL statement
  savepoint x;
psql:sql/plpgsql.sql:1026: ERROR:  current transaction is aborted, commands ignored until end of transaction block
    set constraints all immediate; -- fails
psql:sql/plpgsql.sql:1027: ERROR:  current transaction is aborted, commands ignored until end of transaction block
  rollback to x;
psql:sql/plpgsql.sql:1028: ERROR:  savepoint "x" does not exist
  select trap_foreign_key_2();  -- detects FK violation
psql:sql/plpgsql.sql:1029: ERROR:  current transaction is aborted, commands ignored until end of transaction block
commit;				-- still fails
ROLLBACK
drop function trap_foreign_key(int);
DROP FUNCTION
drop function trap_foreign_key_2();
DROP FUNCTION
--
-- Test proper snapshot handling in simple expressions
--
create temp table users(login text, id serial);
CREATE TABLE
create function sp_id_user(a_login text) returns int as $$
declare x int;
begin
  select into x id from users where login = a_login;
  if found then return x; end if;
  return 0;
end$$ language plpgsql stable;
CREATE FUNCTION
insert into users values('user1');
INSERT 0 1
select sp_id_user('user1');
 sp_id_user 
------------
          1
(1 row)

select sp_id_user('userx');
 sp_id_user 
------------
          0
(1 row)

create function sp_add_user(a_login text) returns int as $$
declare my_id_user int;
begin
  my_id_user = sp_id_user( a_login );
  IF  my_id_user > 0 THEN
    RETURN -1;  -- error code for existing user
  END IF;
  INSERT INTO users ( login ) VALUES ( a_login );
  my_id_user = sp_id_user( a_login );
  IF  my_id_user = 0 THEN
    RETURN -2;  -- error code for insertion failure
  END IF;
  RETURN my_id_user;
end$$ language plpgsql;
CREATE FUNCTION
select sp_add_user('user1');
 sp_add_user 
-------------
          -1
(1 row)

select sp_add_user('user2');
 sp_add_user 
-------------
           2
(1 row)

select sp_add_user('user2');
 sp_add_user 
-------------
          -1
(1 row)

select sp_add_user('user3');
 sp_add_user 
-------------
           3
(1 row)

select sp_add_user('user3');
 sp_add_user 
-------------
          -1
(1 row)

drop function sp_add_user(text);
DROP FUNCTION
drop function sp_id_user(text);
DROP FUNCTION
--
-- tests for refcursors
--
create table rc_test (a int, b int);
CREATE TABLE
copy rc_test from stdin;
COPY 3
create function return_unnamed_refcursor() returns refcursor as $$
declare
    rc refcursor;
begin
    open rc for select a from rc_test;
    return rc;
end
$$ language plpgsql;
CREATE FUNCTION
create function use_refcursor(rc refcursor) returns int as $$
declare
    rc refcursor;
    x record;
begin
    rc = return_unnamed_refcursor();
    fetch next from rc into x;
    return x.a;
end
$$ language plpgsql;
CREATE FUNCTION
select use_refcursor(return_unnamed_refcursor());
 use_refcursor 
---------------
             5
(1 row)

create function return_refcursor(rc refcursor) returns refcursor as $$
begin
    open rc for select a from rc_test;
    return rc;
end
$$ language plpgsql;
CREATE FUNCTION
create function refcursor_test1(refcursor) returns refcursor as $$
begin
    perform return_refcursor($1);
    return $1;
end
$$ language plpgsql;
CREATE FUNCTION
begin;
BEGIN
select refcursor_test1('test1');
 refcursor_test1 
-----------------
 test1
(1 row)

fetch next in test1;
 a 
---
 5
(1 row)

select refcursor_test1('test2');
 refcursor_test1 
-----------------
 test2
(1 row)

--fetch all from test2;  --[#269] skip the crash case currently
commit;
COMMIT
-- should fail
fetch next from test1;
psql:sql/plpgsql.sql:1135: ERROR:  cursor "test1" does not exist
create function refcursor_test2(int, int) returns boolean as $$
declare
    c1 cursor (param1 int, param2 int) for select * from rc_test where a > param1 and b > param2;
    nonsense record;
begin
    open c1($1, $2);
    fetch c1 into nonsense;
    close c1;
    if found then
        return true;
    else
        return false;
    end if;
end
$$ language plpgsql;
CREATE FUNCTION
select refcursor_test2(20000, 20000) as "Should be false",
       refcursor_test2(20, 20) as "Should be true";
 Should be false | Should be true 
-----------------+----------------
 f               | t
(1 row)

--
-- tests for cursors with named parameter arguments
--
create function namedparmcursor_test1(int, int) returns boolean as $$
declare
    c1 cursor (param1 int, param12 int) for select * from rc_test where a > param1 and b > param12;
    nonsense record;
begin
    open c1(param12 = $2, param1 = $1);
    fetch c1 into nonsense;
    close c1;
    if found then
        return true;
    else
        return false;
    end if;
end
$$ language plpgsql;
CREATE FUNCTION
select namedparmcursor_test1(20000, 20000) as "Should be false",
       namedparmcursor_test1(20, 20) as "Should be true";
psql:sql/plpgsql.sql:1176: ERROR:  column "param12" does not exist
LINE 1: SELECT param12 = $2, param1 = $1;
               ^
QUERY:  SELECT param12 = $2, param1 = $1;
CONTEXT:  PL/pgSQL function namedparmcursor_test1(integer,integer) line 6 at OPEN
-- mixing named and positional argument notations
create function namedparmcursor_test2(int, int) returns boolean as $$
declare
    c1 cursor (param1 int, param2 int) for select * from rc_test where a > param1 and b > param2;
    nonsense record;
begin
    open c1(param1 = $1, $2);
    fetch c1 into nonsense;
    close c1;
    if found then
        return true;
    else
        return false;
    end if;
end
$$ language plpgsql;
CREATE FUNCTION
select namedparmcursor_test2(20, 20);
psql:sql/plpgsql.sql:1194: ERROR:  column "param1" does not exist
LINE 1: SELECT param1 = $1, $2;
               ^
QUERY:  SELECT param1 = $1, $2;
CONTEXT:  PL/pgSQL function namedparmcursor_test2(integer,integer) line 6 at OPEN
-- mixing named and positional: param2 is given twice, once in named notation
-- and second time in positional notation. Should throw an error at parse time
create function namedparmcursor_test3() returns void as $$
declare
    c1 cursor (param1 int, param2 int) for select * from rc_test where a > param1 and b > param2;
begin
    open c1(param2 = 20, 21);
end
$$ language plpgsql;
CREATE FUNCTION
-- mixing named and positional: same as previous test, but param1 is duplicated
create function namedparmcursor_test4() returns void as $$
declare
    c1 cursor (param1 int, param2 int) for select * from rc_test where a > param1 and b > param2;
begin
    open c1(20, param1 = 21);
end
$$ language plpgsql;
CREATE FUNCTION
-- duplicate named parameter, should throw an error at parse time
create function namedparmcursor_test5() returns void as $$
declare
  c1 cursor (p1 int, p2 int) for
    select * from tenk1 where thousand = p1 and tenthous = p2;
begin
  open c1 (p2 = 77, p2 = 42);
end
$$ language plpgsql;
CREATE FUNCTION
-- not enough parameters, should throw an error at parse time
create function namedparmcursor_test6() returns void as $$
declare
  c1 cursor (p1 int, p2 int) for
    select * from tenk1 where thousand = p1 and tenthous = p2;
begin
  open c1 (p2 = 77);
end
$$ language plpgsql;
psql:sql/plpgsql.sql:1233: ERROR:  not enough arguments for cursor "c1"
LINE 6:   open c1 (p2 = 77);
                          ^
-- division by zero runtime error, the context given in the error message
-- should be sensible
create function namedparmcursor_test7() returns void as $$
declare
  c1 cursor (p1 int, p2 int) for
    select * from tenk1 where thousand = p1 and tenthous = p2;
begin
  open c1 (p2 = 77, p1 = 42/0);
end $$ language plpgsql;
CREATE FUNCTION
select namedparmcursor_test7();
psql:sql/plpgsql.sql:1244: ERROR:  column "p2" does not exist
LINE 1: SELECT p2 = 77, p1 = 42/0;
               ^
QUERY:  SELECT p2 = 77, p1 = 42/0;
CONTEXT:  PL/pgSQL function namedparmcursor_test7() line 6 at OPEN
-- check that line comments work correctly within the argument list (there
-- is some special handling of this case in the code: the newline after the
-- comment must be preserved when the argument-evaluating query is
-- constructed, otherwise the comment effectively comments out the next
-- argument, too)
create function namedparmcursor_test8() returns int4 as $$
declare
  c1 cursor (p1 int, p2 int) for
    select count(*) from tenk1 where thousand = p1 and tenthous = p2;
  n int4;
begin
  open c1 (77 -- test
  , 42);
  fetch c1 into n;
  return n;
end $$ language plpgsql;
CREATE FUNCTION
select namedparmcursor_test8();
 namedparmcursor_test8 
-----------------------
                     0
(1 row)

-- cursor parameter name can match plpgsql variable or unreserved keyword
create function namedparmcursor_test9(p1 int) returns int4 as $$
declare
  c1 cursor (p1 int, p2 int, debug int) for
    select count(*) from tenk1 where thousand = p1 and tenthous = p2
      and four = debug;
  p2 int4 = 1006;
  n int4;
begin
  open c1 (p1 = p1, p2 = p2, debug = 2);
  fetch c1 into n;
  return n;
end $$ language plpgsql;
CREATE FUNCTION
select namedparmcursor_test9(6);
psql:sql/plpgsql.sql:1277: ERROR:  column "debug" does not exist
LINE 1: SELECT p1 = p1, p2 = p2, debug = 2;
                                 ^
QUERY:  SELECT p1 = p1, p2 = p2, debug = 2;
CONTEXT:  PL/pgSQL function namedparmcursor_test9(integer) line 9 at OPEN
--
-- tests for "raise" processing
--
create function raise_test1(int) returns int as $$
begin
    raise notice 'This message has too many parameters!', $1;
    return $1;
end;
$$ language plpgsql;
psql:sql/plpgsql.sql:1287: ERROR:  too many parameters specified for RAISE
CONTEXT:  compilation of PL/pgSQL function "raise_test1" near line 3
create function raise_test2(int) returns int as $$
begin
    raise notice 'This message has too few parameters: %, %, %', $1, $1;
    return $1;
end;
$$ language plpgsql;
psql:sql/plpgsql.sql:1294: ERROR:  too few parameters specified for RAISE
CONTEXT:  compilation of PL/pgSQL function "raise_test2" near line 3
create function raise_test3(int) returns int as $$
begin
    raise notice 'This message has no parameters (despite having %% signs in it)!';
    return $1;
end;
$$ language plpgsql;
CREATE FUNCTION
select raise_test3(1);
psql:sql/plpgsql.sql:1303: NOTICE:  This message has no parameters (despite having % signs in it)!
 raise_test3 
-------------
           1
(1 row)

-- Test re-RAISE inside a nested exception block.  This case is allowed
-- by Oracle's PL/SQL but was handled differently by PG before 9.1.
CREATE FUNCTION reraise_test() RETURNS void AS $$
BEGIN
   BEGIN
       RAISE syntax_error;
   EXCEPTION
       WHEN syntax_error THEN
           BEGIN
               raise notice 'exception % thrown in inner block, reraising', sqlerrm;
               RAISE;
           EXCEPTION
               WHEN OTHERS THEN
                   raise notice 'RIGHT - exception % caught in inner block', sqlerrm;
           END;
   END;
EXCEPTION
   WHEN OTHERS THEN
       raise notice 'WRONG - exception % caught in outer block', sqlerrm;
END;
$$ LANGUAGE plpgsql;
CREATE FUNCTION
SELECT reraise_test();
psql:sql/plpgsql.sql:1328: NOTICE:  exception syntax_error thrown in inner block, reraising
psql:sql/plpgsql.sql:1328: NOTICE:  RIGHT - exception syntax_error caught in inner block
 reraise_test 
--------------
 
(1 row)

--
-- reject function definitions that contain malformed SQL queries at
-- compile-time, where possible
--
create function bad_sql1() returns int as $$
declare a int;
begin
    a = 5;
    Johnny Yuma;
    a = 10;
    return a;
end$$ language plpgsql;
psql:sql/plpgsql.sql:1341: ERROR:  syntax error at or near "Johnny"
LINE 5:     Johnny Yuma;
            ^
create function bad_sql2() returns int as $$
declare r record;
begin
    for r in select I fought the law, the law won LOOP
        raise notice 'in loop';
    end loop;
    return 5;
end;$$ language plpgsql;
psql:sql/plpgsql.sql:1350: ERROR:  syntax error at or near "the"
LINE 4:     for r in select I fought the law, the law won LOOP
                                     ^
-- a RETURN expression is mandatory, except for void-returning
-- functions, where it is not allowed
create function missing_return_expr() returns int as $$
begin
    return ;
end;$$ language plpgsql;
psql:sql/plpgsql.sql:1357: ERROR:  missing expression at or near ";"
LINE 3:     return ;
                   ^
create function void_return_expr() returns void as $$
begin
    return 5;
end;$$ language plpgsql;
psql:sql/plpgsql.sql:1362: ERROR:  RETURN cannot have a parameter in function returning void
LINE 3:     return 5;
                   ^
-- VOID functions are allowed to omit RETURN
create function void_return_expr() returns void as $$
begin
    perform 2+2;
end;$$ language plpgsql;
CREATE FUNCTION
select void_return_expr();
 void_return_expr 
------------------
 
(1 row)

-- but ordinary functions are not
create function missing_return_expr() returns int as $$
begin
    perform 2+2;
end;$$ language plpgsql;
CREATE FUNCTION
select missing_return_expr();
psql:sql/plpgsql.sql:1378: ERROR:  control reached end of function without RETURN
CONTEXT:  PL/pgSQL function missing_return_expr()
drop function void_return_expr();
DROP FUNCTION
drop function missing_return_expr();
DROP FUNCTION
--
-- EXECUTE ... INTO test
--
create table eifoo (i integer, y integer);
CREATE TABLE
create type eitype as (i integer, y integer);
CREATE TYPE
create or replace function execute_into_test(varchar) returns record as $$
declare
    _r record;
    _rt eifoo%rowtype;
    _v eitype;
    i int;
    j int;
    k int;
begin
    execute 'insert into '||$1||' values(10,15)';
    execute 'select (row).* from (select row(10,1)::eifoo) s' into _r;
    raise notice '% %', _r.i, _r.y;
    execute 'select * from '||$1||' limit 1' into _rt;
    raise notice '% %', _rt.i, _rt.y;
    execute 'select *, 20 from '||$1||' limit 1' into i, j, k;
    raise notice '% % %', i, j, k;
    execute 'select 1,2' into _v;
    return _v;
end; $$ language plpgsql;
CREATE FUNCTION
select execute_into_test('eifoo');
psql:sql/plpgsql.sql:1410: NOTICE:  10 1
psql:sql/plpgsql.sql:1410: NOTICE:  10 15
psql:sql/plpgsql.sql:1410: NOTICE:  10 15 20
 execute_into_test 
-------------------
 (1,2)
(1 row)

drop table eifoo cascade;
DROP TABLE
drop type eitype cascade;
DROP TYPE
--
-- SQLSTATE and SQLERRM test
--
create function excpt_test1() returns void as $$
begin
    raise notice '% %', sqlstate, sqlerrm;
end; $$ language plpgsql;
CREATE FUNCTION
-- should fail: SQLSTATE and SQLERRM are only in defined EXCEPTION
-- blocks
select excpt_test1();
psql:sql/plpgsql.sql:1425: ERROR:  column "sqlstate" does not exist
LINE 1: SELECT sqlstate
               ^
QUERY:  SELECT sqlstate
CONTEXT:  PL/pgSQL function excpt_test1() line 3 at RAISE
create function excpt_test2() returns void as $$
begin
    begin
        begin
            raise notice '% %', sqlstate, sqlerrm;
        end;
    end;
end; $$ language plpgsql;
CREATE FUNCTION
-- should fail
select excpt_test2();
psql:sql/plpgsql.sql:1436: ERROR:  column "sqlstate" does not exist
LINE 1: SELECT sqlstate
               ^
QUERY:  SELECT sqlstate
CONTEXT:  PL/pgSQL function excpt_test2() line 5 at RAISE
create function excpt_test3() returns void as $$
begin
    begin
        raise exception 'user exception';
    exception when others then
	    raise notice 'caught exception % %', sqlstate, sqlerrm;
	    begin
	        raise notice '% %', sqlstate, sqlerrm;
	        perform 10/0;
        exception
            when substring_error then
                -- this exception handler shouldn't be invoked
                raise notice 'unexpected exception: % %', sqlstate, sqlerrm;
	        when division_by_zero then
	            raise notice 'caught exception % %', sqlstate, sqlerrm;
	    end;
	    raise notice '% %', sqlstate, sqlerrm;
    end;
end; $$ language plpgsql;
CREATE FUNCTION
select excpt_test3();
psql:sql/plpgsql.sql:1458: NOTICE:  caught exception P0001 user exception
psql:sql/plpgsql.sql:1458: NOTICE:  P0001 user exception
psql:sql/plpgsql.sql:1458: NOTICE:  caught exception 22012 division by zero
psql:sql/plpgsql.sql:1458: NOTICE:  P0001 user exception
 excpt_test3 
-------------
 
(1 row)

create function excpt_test4() returns text as $$
begin
	begin perform 1/0;
	exception when others then return sqlerrm; end;
end; $$ language plpgsql;
CREATE FUNCTION
select excpt_test4();
   excpt_test4    
------------------
 division by zero
(1 row)

drop function excpt_test1();
DROP FUNCTION
drop function excpt_test2();
DROP FUNCTION
drop function excpt_test3();
DROP FUNCTION
drop function excpt_test4();
DROP FUNCTION
-- parameters of raise stmt can be expressions
create function raise_exprs() returns void as $$
declare
    a integer[] = '{10,20,30}';
    c varchar = 'xyz';
    i integer;
begin
    i = 2;
    raise notice '%; %; %; %; %; %', a, a[i], c, (select c || 'abc'), row(10,'aaa',NULL,30), NULL;
end;$$ language plpgsql;
CREATE FUNCTION
select raise_exprs();
psql:sql/plpgsql.sql:1482: NOTICE:  {10,20,30}; 20; xyz; xyzabc; (10,aaa,,30); <NULL>
 raise_exprs 
-------------
 
(1 row)

drop function raise_exprs();
DROP FUNCTION
-- regression test: verify that multiple uses of same plpgsql datum within
-- a SQL command all get mapped to the same $n parameter.  The return value
-- of the SELECT is not important, we only care that it doesn't fail with
-- a complaint about an ungrouped column reference.
create function multi_datum_use(p1 int) returns bool as $$
declare
  x int;
  y int;
begin
  select into x,y unique1/p1, unique1/$1 from tenk1 group by unique1/p1;
  return x = y;
end$$ language plpgsql;
CREATE FUNCTION
select multi_datum_use(42);
 multi_datum_use 
-----------------
 t
(1 row)

--
-- Test STRICT limiter in both planned and EXECUTE invocations.
-- Note that a data-modifying query is quasi strict (disallow multi rows)
-- by default in the planned case, but not in EXECUTE.
--
create temp table foo (f1 int, f2 int);
CREATE TABLE
insert into foo values (1,2), (3,4);
INSERT 0 2
create or replace function stricttest() returns void as $$
declare x record;
begin
  -- should work
  insert into foo values(5,6) returning * into x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
CREATE FUNCTION
select stricttest();
psql:sql/plpgsql.sql:1518: NOTICE:  x.f1 = 5, x.f2 = 6
 stricttest 
------------
 
(1 row)

create or replace function stricttest() returns void as $$
declare x record;
begin
  -- should fail due to implicit strict
  insert into foo values(7,8),(9,10) returning * into x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
CREATE FUNCTION
select stricttest();
psql:sql/plpgsql.sql:1528: ERROR:  query returned more than one row
CONTEXT:  PL/pgSQL function stricttest() line 5 at SQL statement
create or replace function stricttest() returns void as $$
declare x record;
begin
  -- should work
  execute 'insert into foo values(5,6) returning *' into x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
CREATE FUNCTION
select stricttest();
psql:sql/plpgsql.sql:1537: NOTICE:  x.f1 = 5, x.f2 = 6
 stricttest 
------------
 
(1 row)

create or replace function stricttest() returns void as $$
declare x record;
begin
  -- this should work since EXECUTE isn't as picky
  execute 'insert into foo values(7,8),(9,10) returning *' into x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
CREATE FUNCTION
select stricttest();
psql:sql/plpgsql.sql:1547: NOTICE:  x.f1 = 7, x.f2 = 8
 stricttest 
------------
 
(1 row)

select * from foo;
 f1 | f2 
----+----
  1 |  2
  3 |  4
  5 |  6
  5 |  6
  7 |  8
  9 | 10
(6 rows)

create or replace function stricttest() returns void as $$
declare x record;
begin
  -- should work
  select * from foo where f1 = 3 into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
CREATE FUNCTION
select stricttest();
psql:sql/plpgsql.sql:1559: NOTICE:  x.f1 = 3, x.f2 = 4
 stricttest 
------------
 
(1 row)

create or replace function stricttest() returns void as $$
declare x record;
begin
  -- should fail, no rows
  select * from foo where f1 = 0 into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
CREATE FUNCTION
select stricttest();
psql:sql/plpgsql.sql:1569: ERROR:  query returned no rows
CONTEXT:  PL/pgSQL function stricttest() line 5 at SQL statement
create or replace function stricttest() returns void as $$
declare x record;
begin
  -- should fail, too many rows
  select * from foo where f1 > 3 into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
CREATE FUNCTION
select stricttest();
psql:sql/plpgsql.sql:1579: ERROR:  query returned more than one row
CONTEXT:  PL/pgSQL function stricttest() line 5 at SQL statement
create or replace function stricttest() returns void as $$
declare x record;
begin
  -- should work
  execute 'select * from foo where f1 = 3' into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
CREATE FUNCTION
select stricttest();
psql:sql/plpgsql.sql:1589: NOTICE:  x.f1 = 3, x.f2 = 4
 stricttest 
------------
 
(1 row)

create or replace function stricttest() returns void as $$
declare x record;
begin
  -- should fail, no rows
  execute 'select * from foo where f1 = 0' into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
CREATE FUNCTION
select stricttest();
psql:sql/plpgsql.sql:1599: ERROR:  query returned no rows
CONTEXT:  PL/pgSQL function stricttest() line 5 at EXECUTE
create or replace function stricttest() returns void as $$
declare x record;
begin
  -- should fail, too many rows
  execute 'select * from foo where f1 > 3' into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
CREATE FUNCTION
select stricttest();
psql:sql/plpgsql.sql:1609: ERROR:  query returned more than one row
CONTEXT:  PL/pgSQL function stricttest() line 5 at EXECUTE
drop function stricttest();
DROP FUNCTION
-- test printing parameters after failure due to STRICT
set plpgsql.print_strict_params to true;
SET
create or replace function stricttest() returns void as $$
declare
x record;
p1 int = 2;
p3 text = 'foo';
begin
  -- no rows
  select * from foo where f1 = p1 and f1::text = p3 into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
CREATE FUNCTION
select stricttest();
psql:sql/plpgsql.sql:1628: ERROR:  query returned no rows
DETAIL:  parameters: p1 = '2', p3 = 'foo'
CONTEXT:  PL/pgSQL function stricttest() line 8 at SQL statement
create or replace function stricttest() returns void as $$
declare
x record;
p1 int = 2;
p3 text = 'foo';
begin
  -- too many rows
  select * from foo where f1 > p1 or f1::text = p3  into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
CREATE FUNCTION
select stricttest();
psql:sql/plpgsql.sql:1641: ERROR:  query returned more than one row
DETAIL:  parameters: p1 = '2', p3 = 'foo'
CONTEXT:  PL/pgSQL function stricttest() line 8 at SQL statement
create or replace function stricttest() returns void as $$
declare x record;
begin
  -- too many rows, no params
  select * from foo where f1 > 3 into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
CREATE FUNCTION
select stricttest();
psql:sql/plpgsql.sql:1651: ERROR:  query returned more than one row
CONTEXT:  PL/pgSQL function stricttest() line 5 at SQL statement
create or replace function stricttest() returns void as $$
declare x record;
begin
  -- no rows
  execute 'select * from foo where f1 = $1 or f1::text = $2' using 0, 'foo' into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
CREATE FUNCTION
select stricttest();
psql:sql/plpgsql.sql:1661: ERROR:  query returned no rows
DETAIL:  parameters: $1 = '0', $2 = 'foo'
CONTEXT:  PL/pgSQL function stricttest() line 5 at EXECUTE
create or replace function stricttest() returns void as $$
declare x record;
begin
  -- too many rows
  execute 'select * from foo where f1 > $1' using 1 into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
CREATE FUNCTION
select stricttest();
psql:sql/plpgsql.sql:1671: ERROR:  query returned more than one row
DETAIL:  parameters: $1 = '1'
CONTEXT:  PL/pgSQL function stricttest() line 5 at EXECUTE
create or replace function stricttest() returns void as $$
declare x record;
begin
  -- too many rows, no parameters
  execute 'select * from foo where f1 > 3' into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
CREATE FUNCTION
select stricttest();
psql:sql/plpgsql.sql:1681: ERROR:  query returned more than one row
CONTEXT:  PL/pgSQL function stricttest() line 5 at EXECUTE
create or replace function stricttest() returns void as $$
-- override the global
#print_strict_params off
declare
x record;
p1 int = 2;
p3 text = 'foo';
begin
  -- too many rows
  select * from foo where f1 > p1 or f1::text = p3  into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
CREATE FUNCTION
select stricttest();
psql:sql/plpgsql.sql:1697: ERROR:  query returned more than one row
CONTEXT:  PL/pgSQL function stricttest() line 10 at SQL statement
reset plpgsql.print_strict_params;
RESET
create or replace function stricttest() returns void as $$
-- override the global
#print_strict_params on
declare
x record;
p1 int = 2;
p3 text = 'foo';
begin
  -- too many rows
  select * from foo where f1 > p1 or f1::text = p3  into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
CREATE FUNCTION
select stricttest();
psql:sql/plpgsql.sql:1714: ERROR:  query returned more than one row
DETAIL:  parameters: p1 = '2', p3 = 'foo'
CONTEXT:  PL/pgSQL function stricttest() line 10 at SQL statement
-- test warnings and errors
set plpgsql.extra_warnings to 'all';
SET
set plpgsql.extra_warnings to 'none';
SET
set plpgsql.extra_errors to 'all';
SET
set plpgsql.extra_errors to 'none';
SET
-- test warnings when shadowing a variable
set plpgsql.extra_warnings to 'shadowed_variables';
SET
-- simple shadowing of input and output parameters
create or replace function shadowtest(in1 int)
	returns table (out1 int) as $$
declare
in1 int;
out1 int;
begin
end
$$ language plpgsql;
psql:sql/plpgsql.sql:1734: WARNING:  variable "in1" shadows a previously defined variable
LINE 4: in1 int;
        ^
psql:sql/plpgsql.sql:1734: WARNING:  variable "out1" shadows a previously defined variable
LINE 5: out1 int;
        ^
CREATE FUNCTION
select shadowtest(1);
 shadowtest 
------------
(0 rows)

set plpgsql.extra_warnings to 'shadowed_variables';
SET
select shadowtest(1);
 shadowtest 
------------
(0 rows)

create or replace function shadowtest(in1 int)
	returns table (out1 int) as $$
declare
in1 int;
out1 int;
begin
end
$$ language plpgsql;
psql:sql/plpgsql.sql:1745: WARNING:  variable "in1" shadows a previously defined variable
LINE 4: in1 int;
        ^
psql:sql/plpgsql.sql:1745: WARNING:  variable "out1" shadows a previously defined variable
LINE 5: out1 int;
        ^
CREATE FUNCTION
select shadowtest(1);
 shadowtest 
------------
(0 rows)

drop function shadowtest(int);
DROP FUNCTION
-- shadowing in a second DECLARE block
create or replace function shadowtest()
	returns void as $$
declare
f1 int;
begin
	declare
	f1 int;
	begin
	end;
end$$ language plpgsql;
psql:sql/plpgsql.sql:1759: WARNING:  variable "f1" shadows a previously defined variable
LINE 7:  f1 int;
         ^
CREATE FUNCTION
drop function shadowtest();
DROP FUNCTION
-- several levels of shadowing
create or replace function shadowtest(in1 int)
	returns void as $$
declare
in1 int;
begin
	declare
	in1 int;
	begin
	end;
end$$ language plpgsql;
psql:sql/plpgsql.sql:1772: WARNING:  variable "in1" shadows a previously defined variable
LINE 4: in1 int;
        ^
psql:sql/plpgsql.sql:1772: WARNING:  variable "in1" shadows a previously defined variable
LINE 7:  in1 int;
         ^
CREATE FUNCTION
drop function shadowtest(int);
DROP FUNCTION
-- shadowing in cursor definitions
create or replace function shadowtest()
	returns void as $$
declare
f1 int;
c1 cursor (f1 int) for select 1;
begin
end$$ language plpgsql;
psql:sql/plpgsql.sql:1782: WARNING:  variable "f1" shadows a previously defined variable
LINE 5: c1 cursor (f1 int) for select 1;
                   ^
CREATE FUNCTION
drop function shadowtest();
DROP FUNCTION
-- test errors when shadowing a variable
set plpgsql.extra_errors to 'shadowed_variables';
SET
create or replace function shadowtest(f1 int)
	returns boolean as $$
declare f1 int; begin return 1; end $$ language plpgsql;
psql:sql/plpgsql.sql:1791: ERROR:  variable "f1" shadows a previously defined variable
LINE 3: declare f1 int; begin return 1; end $$ language plpgsql;
                ^
select shadowtest(1);
psql:sql/plpgsql.sql:1794: ERROR:  function shadowtest(integer) does not exist
LINE 1: select shadowtest(1);
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
reset plpgsql.extra_errors;
RESET
reset plpgsql.extra_warnings;
RESET
create or replace function shadowtest(f1 int)
	returns boolean as $$
declare f1 int; begin return 1; end $$ language plpgsql;
CREATE FUNCTION
select shadowtest(1);
 shadowtest 
------------
 t
(1 row)

-- test scrollable cursor support
create function sc_test() returns setof integer as $$
declare
  c scroll cursor for select f1 from int4_tbl;
  x integer;
begin
  open c;
  fetch last from c into x;
  while found loop
    return next x;
    fetch prior from c into x;
  end loop;
  close c;
end;
$$ language plpgsql;
CREATE FUNCTION
select * from sc_test();
   sc_test   
-------------
 -2147483647
  2147483647
     -123456
      123456
           0
(5 rows)

create or replace function sc_test() returns setof integer as $$
declare
  c no scroll cursor for select f1 from int4_tbl;
  x integer;
begin
  open c;
  fetch last from c into x;
  while found loop
    return next x;
    fetch prior from c into x;
  end loop;
  close c;
end;
$$ language plpgsql;
CREATE FUNCTION
select * from sc_test();  -- fails because of NO SCROLL specification
psql:sql/plpgsql.sql:1839: ERROR:  cursor can only scan forward
HINT:  Declare it with SCROLL option to enable backward scan.
CONTEXT:  PL/pgSQL function sc_test() line 7 at FETCH
create or replace function sc_test() returns setof integer as $$
declare
  c refcursor;
  x integer;
begin
  open c scroll for select f1 from int4_tbl;
  fetch last from c into x;
  while found loop
    return next x;
    fetch prior from c into x;
  end loop;
  close c;
end;
$$ language plpgsql;
CREATE FUNCTION
select * from sc_test();
   sc_test   
-------------
 -2147483647
  2147483647
     -123456
      123456
           0
(5 rows)

create or replace function sc_test() returns setof integer as $$
declare
  c refcursor;
  x integer;
begin
  open c scroll for execute 'select f1 from int4_tbl';
  fetch last from c into x;
  while found loop
    return next x;
    fetch relative -2 from c into x;
  end loop;
  close c;
end;
$$ language plpgsql;
CREATE FUNCTION
select * from sc_test();
   sc_test   
-------------
 -2147483647
     -123456
           0
(3 rows)

create or replace function sc_test() returns setof integer as $$
declare
  c refcursor;
  x integer;
begin
  open c scroll for execute 'select f1 from int4_tbl';
  fetch last from c into x;
  while found loop
    return next x;
    move backward 2 from c;
    fetch relative -1 from c into x;
  end loop;
  close c;
end;
$$ language plpgsql;
CREATE FUNCTION
select * from sc_test();
   sc_test   
-------------
 -2147483647
      123456
(2 rows)

create or replace function sc_test() returns setof integer as $$
declare
  c cursor for select * from generate_series(1, 10);
  x integer;
begin
  open c;
  loop
      move relative 2 in c;
      if not found then
          exit;
      end if;
      fetch next from c into x;
      if found then
          return next x;
      end if;
  end loop;
  close c;
end;
$$ language plpgsql;
CREATE FUNCTION
select * from sc_test();
 sc_test 
---------
       3
       6
       9
(3 rows)

create or replace function sc_test() returns setof integer as $$
declare
  c cursor for select * from generate_series(1, 10);
  x integer;
begin
  open c;
  move forward all in c;
  fetch backward from c into x;
  if found then
    return next x;
  end if;
  close c;
end;
$$ language plpgsql;
CREATE FUNCTION
select * from sc_test();
 sc_test 
---------
      10
(1 row)

drop function sc_test();
DROP FUNCTION
-- test qualified variable names
create function pl_qual_names (param1 int) returns void as $$
<<outerblock>>
declare
  param1 int = 1;
begin
  <<innerblock>>
  declare
    param1 int = 2;
  begin
    raise notice 'param1 = %', param1;
    raise notice 'pl_qual_names.param1 = %', pl_qual_names.param1;
    raise notice 'outerblock.param1 = %', outerblock.param1;
    raise notice 'innerblock.param1 = %', innerblock.param1;
  end;
end;
$$ language plpgsql;
CREATE FUNCTION
select pl_qual_names(42);
psql:sql/plpgsql.sql:1952: NOTICE:  param1 = 2
psql:sql/plpgsql.sql:1952: NOTICE:  pl_qual_names.param1 = 42
psql:sql/plpgsql.sql:1952: NOTICE:  outerblock.param1 = 1
psql:sql/plpgsql.sql:1952: NOTICE:  innerblock.param1 = 2
 pl_qual_names 
---------------
 
(1 row)

drop function pl_qual_names(int);
DROP FUNCTION
-- tests for RETURN QUERY
create function ret_query1(out int, out int) returns setof record as $$
begin
    $1 = -1;
    $2 = -2;
    return next;
    return query select x + 1, x * 10 from generate_series(0, 10) s (x);
    return next;
end;
$$ language plpgsql;
CREATE FUNCTION
select * from ret_query1();
 column1 | column2 
---------+---------
      -1 |      -2
       1 |       0
       2 |      10
       3 |      20
       4 |      30
       5 |      40
       6 |      50
       7 |      60
       8 |      70
       9 |      80
      10 |      90
      11 |     100
      -1 |      -2
(13 rows)

create type record_type as (x text, y int, z boolean);
CREATE TYPE
create or replace function ret_query2(lim int) returns setof record_type as $$
begin
    return query select md5(s.x::text), s.x, s.x > 0
                 from generate_series(-8, lim) s (x) where s.x % 2 = 0;
end;
$$ language plpgsql;
CREATE FUNCTION
select * from ret_query2(8);
                x                 | y  | z 
----------------------------------+----+---
 a8d2ec85eaf98407310b72eb73dda247 | -8 | f
 596a3d04481816330f07e4f97510c28f | -6 | f
 0267aaf632e87a63288a08331f22c7c3 | -4 | f
 5d7b9adcbe1c629ec722529dd12e5129 | -2 | f
 cfcd208495d565ef66e7dff9f98764da |  0 | f
 c81e728d9d4c2f636f067f89cc14862c |  2 | t
 a87ff679a2f3e71d9181a67b7542122c |  4 | t
 1679091c5a880faf6fb5e6087eb1b2dc |  6 | t
 c9f0f895fb98ab9159f51fd0297e236d |  8 | t
(9 rows)

-- test EXECUTE USING
create function exc_using(int, text) returns int as $$
declare i int;
begin
  for i in execute 'select * from generate_series(1,$1)' using $1+1 loop
    raise notice '%', i;
  end loop;
  execute 'select $2 + $2*3 + length($1)' into i using $2,$1;
  return i;
end
$$ language plpgsql;
CREATE FUNCTION
select exc_using(5, 'foobar');
psql:sql/plpgsql.sql:1992: NOTICE:  1
psql:sql/plpgsql.sql:1992: NOTICE:  2
psql:sql/plpgsql.sql:1992: NOTICE:  3
psql:sql/plpgsql.sql:1992: NOTICE:  4
psql:sql/plpgsql.sql:1992: NOTICE:  5
psql:sql/plpgsql.sql:1992: NOTICE:  6
 exc_using 
-----------
        26
(1 row)

drop function exc_using(int, text);
DROP FUNCTION
create or replace function exc_using(int) returns void as $$
declare
  c refcursor;
  i int;
begin
  open c for execute 'select * from generate_series(1,$1)' using $1+1;
  loop
    fetch c into i;
    exit when not found;
    raise notice '%', i;
  end loop;
  close c;
  return;
end;
$$ language plpgsql;
CREATE FUNCTION
select exc_using(5);
psql:sql/plpgsql.sql:2011: NOTICE:  1
psql:sql/plpgsql.sql:2011: NOTICE:  2
psql:sql/plpgsql.sql:2011: NOTICE:  3
psql:sql/plpgsql.sql:2011: NOTICE:  4
psql:sql/plpgsql.sql:2011: NOTICE:  5
psql:sql/plpgsql.sql:2011: NOTICE:  6
 exc_using 
-----------
 
(1 row)

drop function exc_using(int);
DROP FUNCTION
-- test FOR-over-cursor
create or replace function forc01() returns void as $$
declare
  c cursor(r1 integer, r2 integer)
       for select * from generate_series(r1,r2) i;
  c2 cursor
       for select * from generate_series(41,43) i;
begin
  for r in c(5,7) loop
    raise notice '% from %', r.i, c;
  end loop;
  -- again, to test if cursor was closed properly
  for r in c(9,10) loop
    raise notice '% from %', r.i, c;
  end loop;
  -- and test a parameterless cursor
  for r in c2 loop
    raise notice '% from %', r.i, c2;
  end loop;
  -- and try it with a hand-assigned name
  raise notice 'after loop, c2 = %', c2;
  c2 = 'special_name';
  for r in c2 loop
    raise notice '% from %', r.i, c2;
  end loop;
  raise notice 'after loop, c2 = %', c2;
  -- and try it with a generated name
  -- (which we can't show in the output because it's variable)
  c2 = null;
  for r in c2 loop
    raise notice '%', r.i;
  end loop;
  raise notice 'after loop, c2 = %', c2;
  return;
end;
$$ language plpgsql;
CREATE FUNCTION
select forc01();
psql:sql/plpgsql.sql:2050: NOTICE:  5 from c
psql:sql/plpgsql.sql:2050: NOTICE:  6 from c
psql:sql/plpgsql.sql:2050: NOTICE:  7 from c
psql:sql/plpgsql.sql:2050: NOTICE:  9 from c
psql:sql/plpgsql.sql:2050: NOTICE:  10 from c
psql:sql/plpgsql.sql:2050: NOTICE:  41 from c2
psql:sql/plpgsql.sql:2050: NOTICE:  42 from c2
psql:sql/plpgsql.sql:2050: NOTICE:  43 from c2
psql:sql/plpgsql.sql:2050: NOTICE:  after loop, c2 = c2
psql:sql/plpgsql.sql:2050: NOTICE:  41 from special_name
psql:sql/plpgsql.sql:2050: NOTICE:  42 from special_name
psql:sql/plpgsql.sql:2050: NOTICE:  43 from special_name
psql:sql/plpgsql.sql:2050: NOTICE:  after loop, c2 = special_name
psql:sql/plpgsql.sql:2050: NOTICE:  41
psql:sql/plpgsql.sql:2050: NOTICE:  42
psql:sql/plpgsql.sql:2050: NOTICE:  43
psql:sql/plpgsql.sql:2050: NOTICE:  after loop, c2 = <NULL>
 forc01 
--------
 
(1 row)

-- try updating the cursor's current row
--create temp table forc_test as
--  select n as i, n as j from generate_series(1,10) n;
create or replace function forc01() returns void as $$
declare
  c cursor for select * from forc_test;
begin
  for r in c loop
    raise notice '%, %', r.i, r.j;
    update forc_test set i = i * 100, j = r.j * 2 where current of c;
  end loop;
end;
$$ language plpgsql;
CREATE FUNCTION
--select forc01();
--select * from forc_test;
-- same, with a cursor whose portal name doesn't match variable name
create or replace function forc01() returns void as $$
declare
  c refcursor = 'fooled_ya';
  r record;
begin
  open c for select * from forc_test;
  loop
    fetch c into r;
    exit when not found;
    raise notice '%, %', r.i, r.j;
    update forc_test set i = i * 100, j = r.j * 2 where current of c;
  end loop;
end;
$$ language plpgsql;
CREATE FUNCTION
--select forc01();
--select * from forc_test;
drop function forc01();
DROP FUNCTION
-- fail because cursor has no query bound to it
create or replace function forc_bad() returns void as $$
declare
  c refcursor;
begin
  for r in c loop
    raise notice '%', r.i;
  end loop;
end;
$$ language plpgsql;
psql:sql/plpgsql.sql:2104: ERROR:  cursor FOR loop must use a bound cursor variable
LINE 5:   for r in c loop
                   ^
-- test RETURN QUERY EXECUTE
create or replace function return_dquery()
returns setof int as $$
begin
  return query execute 'select * from (values(10),(20)) f';
  return query execute 'select * from (values($1),($2)) f' using 40,50;
end;
$$ language plpgsql;
CREATE FUNCTION
select * from return_dquery();
 return_dquery 
---------------
            10
            20
            40
            50
(4 rows)

drop function return_dquery();
DROP FUNCTION
-- test RETURN QUERY with dropped columns
create table tabwithcols(a int, b int, c int, d int);
CREATE TABLE
insert into tabwithcols values(10,20,30,40),(50,60,70,80);
INSERT 0 2
create or replace function returnqueryf()
returns setof tabwithcols as $$
begin
  return query select * from tabwithcols;
  return query execute 'select * from tabwithcols';
end;
$$ language plpgsql;
CREATE FUNCTION
select * from returnqueryf();
 a  | b  | c  | d  
----+----+----+----
 10 | 20 | 30 | 40
 50 | 60 | 70 | 80
 10 | 20 | 30 | 40
 50 | 60 | 70 | 80
(4 rows)

alter table tabwithcols drop column b;
ALTER TABLE
select * from returnqueryf();
 a  | c  | d  
----+----+----
 10 | 30 | 40
 50 | 70 | 80
 10 | 30 | 40
 50 | 70 | 80
(4 rows)

alter table tabwithcols drop column d;
ALTER TABLE
select * from returnqueryf();
 a  | c  
----+----
 10 | 30
 50 | 70
 10 | 30
 50 | 70
(4 rows)

alter table tabwithcols add column d int;
ALTER TABLE
select * from returnqueryf();
 a  | c  | d 
----+----+---
 10 | 30 |  
 50 | 70 |  
 10 | 30 |  
 50 | 70 |  
(4 rows)

drop function returnqueryf();
DROP FUNCTION
drop table tabwithcols;
DROP TABLE
--
-- Tests for composite-type results
--
create type compostype as (x int, y varchar);
CREATE TYPE
-- test: use of variable of composite type in return statement
create or replace function compos() returns compostype as $$
declare
  v compostype;
begin
  v = (1, 'hello');
  return v;
end;
$$ language plpgsql;
CREATE FUNCTION
select compos();
  compos   
-----------
 (1,hello)
(1 row)

-- test: use of variable of record type in return statement
create or replace function compos() returns compostype as $$
declare
  v record;
begin
  v = (1, 'hello'::varchar);
  return v;
end;
$$ language plpgsql;
CREATE FUNCTION
select compos();
  compos   
-----------
 (1,hello)
(1 row)

-- test: use of row expr in return statement
create or replace function compos() returns compostype as $$
begin
  return (1, 'hello'::varchar);
end;
$$ language plpgsql;
CREATE FUNCTION
select compos();
  compos   
-----------
 (1,hello)
(1 row)

-- this does not work currently (no implicit casting)
create or replace function compos() returns compostype as $$
begin
  return (1, 'hello');
end;
$$ language plpgsql;
CREATE FUNCTION
select compos();
psql:sql/plpgsql.sql:2194: ERROR:  returned record type does not match expected record type
DETAIL:  Returned type unknown does not match expected type character varying in column 2.
CONTEXT:  PL/pgSQL function compos() while casting return value to function's return type
-- ... but this does
create or replace function compos() returns compostype as $$
begin
  return (1, 'hello')::compostype;
end;
$$ language plpgsql;
CREATE FUNCTION
select compos();
  compos   
-----------
 (1,hello)
(1 row)

drop function compos();
DROP FUNCTION
-- test: return a row expr as record.
create or replace function composrec() returns record as $$
declare
  v record;
begin
  v = (1, 'hello');
  return v;
end;
$$ language plpgsql;
CREATE FUNCTION
select composrec();
 composrec 
-----------
 (1,hello)
(1 row)

-- test: return row expr in return statement.
create or replace function composrec() returns record as $$
begin
  return (1, 'hello');
end;
$$ language plpgsql;
CREATE FUNCTION
select composrec();
 composrec 
-----------
 (1,hello)
(1 row)

drop function composrec();
DROP FUNCTION
-- test: use invalid expr in return statement.
create or replace function compos() returns compostype as $$
begin
  return 1 + 1;
end;
$$ language plpgsql;
CREATE FUNCTION
select compos();
psql:sql/plpgsql.sql:2237: ERROR:  cannot return non-composite value from function returning composite type
CONTEXT:  PL/pgSQL function compos() line 3 at RETURN
-- RETURN variable is a different code path ...
create or replace function compos() returns compostype as $$
declare x int = 42;
begin
  return x;
end;
$$ language plpgsql;
CREATE FUNCTION
select * from compos();
psql:sql/plpgsql.sql:2247: ERROR:  cannot return non-composite value from function returning composite type
CONTEXT:  PL/pgSQL function compos() line 4 at RETURN
drop function compos();
DROP FUNCTION
-- test: invalid use of composite variable in scalar-returning function
create or replace function compos() returns int as $$
declare
  v compostype;
begin
  v = (1, 'hello');
  return v;
end;
$$ language plpgsql;
CREATE FUNCTION
select compos();
psql:sql/plpgsql.sql:2261: ERROR:  invalid input syntax for integer: "(1,hello)"
CONTEXT:  PL/pgSQL function compos() while casting return value to function's return type
-- test: invalid use of composite expression in scalar-returning function
create or replace function compos() returns int as $$
begin
  return (1, 'hello')::compostype;
end;
$$ language plpgsql;
CREATE FUNCTION
select compos();
psql:sql/plpgsql.sql:2270: ERROR:  invalid input syntax for integer: "(1,hello)"
CONTEXT:  PL/pgSQL function compos() while casting return value to function's return type
drop function compos();
DROP FUNCTION
drop type compostype;
DROP TYPE
--
-- Tests for 8.4's new RAISE features
--
create or replace function raise_test() returns void as $$
begin
  raise notice '% % %', 1, 2, 3
     using errcode = '55001', detail = 'some detail info', hint = 'some hint';
  raise '% % %', 1, 2, 3
     using errcode = 'division_by_zero', detail = 'some detail info';
end;
$$ language plpgsql;
CREATE FUNCTION
select raise_test();
psql:sql/plpgsql.sql:2287: NOTICE:  1 2 3
DETAIL:  some detail info
HINT:  some hint
psql:sql/plpgsql.sql:2287: ERROR:  1 2 3
DETAIL:  some detail info
CONTEXT:  PL/pgSQL function raise_test() line 5 at RAISE
-- Since we can't actually see the thrown SQLSTATE in default psql output,
-- test it like this; this also tests re-RAISE
create or replace function raise_test() returns void as $$
begin
  raise 'check me'
     using errcode = 'division_by_zero', detail = 'some detail info';
  exception
    when others then
      raise notice 'SQLSTATE: % SQLERRM: %', sqlstate, sqlerrm;
      raise;
end;
$$ language plpgsql;
CREATE FUNCTION
select raise_test();
psql:sql/plpgsql.sql:2303: NOTICE:  SQLSTATE: 22012 SQLERRM: check me
psql:sql/plpgsql.sql:2303: ERROR:  check me
DETAIL:  some detail info
CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE
create or replace function raise_test() returns void as $$
begin
  raise 'check me'
     using errcode = '1234F', detail = 'some detail info';
  exception
    when others then
      raise notice 'SQLSTATE: % SQLERRM: %', sqlstate, sqlerrm;
      raise;
end;
$$ language plpgsql;
CREATE FUNCTION
select raise_test();
psql:sql/plpgsql.sql:2314: NOTICE:  SQLSTATE: 1234F SQLERRM: check me
psql:sql/plpgsql.sql:2314: ERROR:  check me
DETAIL:  some detail info
CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE
-- SQLSTATE specification in WHEN
create or replace function raise_test() returns void as $$
begin
  raise 'check me'
     using errcode = '1234F', detail = 'some detail info';
  exception
    when sqlstate '1234F' then
      raise notice 'SQLSTATE: % SQLERRM: %', sqlstate, sqlerrm;
      raise;
end;
$$ language plpgsql;
CREATE FUNCTION
select raise_test();
psql:sql/plpgsql.sql:2328: NOTICE:  SQLSTATE: 1234F SQLERRM: check me
psql:sql/plpgsql.sql:2328: ERROR:  check me
DETAIL:  some detail info
CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE
create or replace function raise_test() returns void as $$
begin
  raise division_by_zero using detail = 'some detail info';
  exception
    when others then
      raise notice 'SQLSTATE: % SQLERRM: %', sqlstate, sqlerrm;
      raise;
end;
$$ language plpgsql;
CREATE FUNCTION
select raise_test();
psql:sql/plpgsql.sql:2340: NOTICE:  SQLSTATE: 22012 SQLERRM: division_by_zero
psql:sql/plpgsql.sql:2340: ERROR:  division_by_zero
DETAIL:  some detail info
CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE
create or replace function raise_test() returns void as $$
begin
  raise division_by_zero;
end;
$$ language plpgsql;
CREATE FUNCTION
select raise_test();
psql:sql/plpgsql.sql:2347: ERROR:  division_by_zero
CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE
create or replace function raise_test() returns void as $$
begin
  raise sqlstate '1234F';
end;
$$ language plpgsql;
CREATE FUNCTION
select raise_test();
psql:sql/plpgsql.sql:2355: ERROR:  1234F
CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE
create or replace function raise_test() returns void as $$
begin
  raise division_by_zero using message = 'custom' || ' message';
end;
$$ language plpgsql;
CREATE FUNCTION
select raise_test();
psql:sql/plpgsql.sql:2363: ERROR:  custom message
CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE
create or replace function raise_test() returns void as $$
begin
  raise using message = 'custom' || ' message', errcode = '22012';
end;
$$ language plpgsql;
CREATE FUNCTION
select raise_test();
psql:sql/plpgsql.sql:2371: ERROR:  custom message
CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE
-- conflict on message
create or replace function raise_test() returns void as $$
begin
  raise notice 'some message' using message = 'custom' || ' message', errcode = '22012';
end;
$$ language plpgsql;
CREATE FUNCTION
select raise_test();
psql:sql/plpgsql.sql:2380: ERROR:  RAISE option already specified: MESSAGE
CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE
-- conflict on errcode
create or replace function raise_test() returns void as $$
begin
  raise division_by_zero using message = 'custom' || ' message', errcode = '22012';
end;
$$ language plpgsql;
CREATE FUNCTION
select raise_test();
psql:sql/plpgsql.sql:2389: ERROR:  RAISE option already specified: ERRCODE
CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE
-- nothing to re-RAISE
create or replace function raise_test() returns void as $$
begin
  raise;
end;
$$ language plpgsql;
CREATE FUNCTION
select raise_test();
psql:sql/plpgsql.sql:2398: ERROR:  RAISE without parameters cannot be used outside an exception handler
CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE
-- test access to exception data
create function zero_divide() returns int as $$
declare v int = 0;
begin
  return 10 / v;
end;
$$ language plpgsql;
CREATE FUNCTION
create or replace function raise_test() returns void as $$
begin
  raise exception 'custom exception'
     using detail = 'some detail of custom exception',
           hint = 'some hint related to custom exception';
end;
$$ language plpgsql;
CREATE FUNCTION
create function stacked_diagnostics_test() returns void as $$
declare _sqlstate text;
        _message text;
        _context text;
begin
  perform zero_divide();
exception when others then
  get stacked diagnostics
        _sqlstate = returned_sqlstate,
        _message = message_text,
        _context = pg_exception_context;
  raise notice 'sqlstate: %, message: %, context: [%]',
    _sqlstate, _message, replace(_context, E'\n', ' <- ');
end;
$$ language plpgsql;
CREATE FUNCTION
select stacked_diagnostics_test();
psql:sql/plpgsql.sql:2432: NOTICE:  sqlstate: 22012, message: division by zero, context: [PL/pgSQL function zero_divide() line 4 at RETURN <- SQL statement "SELECT zero_divide()" <- PL/pgSQL function stacked_diagnostics_test() line 6 at PERFORM]
 stacked_diagnostics_test 
--------------------------
 
(1 row)

create or replace function stacked_diagnostics_test() returns void as $$
declare _detail text;
        _hint text;
        _message text;
begin
  perform raise_test();
exception when others then
  get stacked diagnostics
        _message = message_text,
        _detail = pg_exception_detail,
        _hint = pg_exception_hint;
  raise notice 'message: %, detail: %, hint: %', _message, _detail, _hint;
end;
$$ language plpgsql;
CREATE FUNCTION
select stacked_diagnostics_test();
psql:sql/plpgsql.sql:2449: NOTICE:  message: custom exception, detail: some detail of custom exception, hint: some hint related to custom exception
 stacked_diagnostics_test 
--------------------------
 
(1 row)

-- fail, cannot use stacked diagnostics statement outside handler
create or replace function stacked_diagnostics_test() returns void as $$
declare _detail text;
        _hint text;
        _message text;
begin
  get stacked diagnostics
        _message = message_text,
        _detail = pg_exception_detail,
        _hint = pg_exception_hint;
  raise notice 'message: %, detail: %, hint: %', _message, _detail, _hint;
end;
$$ language plpgsql;
CREATE FUNCTION
select stacked_diagnostics_test();
psql:sql/plpgsql.sql:2465: ERROR:  GET STACKED DIAGNOSTICS cannot be used outside an exception handler
CONTEXT:  PL/pgSQL function stacked_diagnostics_test() line 6 at GET STACKED DIAGNOSTICS
drop function zero_divide();
DROP FUNCTION
drop function stacked_diagnostics_test();
DROP FUNCTION
-- check cases where implicit SQLSTATE variable could be confused with
-- SQLSTATE as a keyword, cf bug #5524
create or replace function raise_test() returns void as $$
begin
  perform 1/0;
exception
  when sqlstate '22012' then
    raise notice using message = sqlstate;
    raise sqlstate '22012' using message = 'substitute message';
end;
$$ language plpgsql;
CREATE FUNCTION
select raise_test();
psql:sql/plpgsql.sql:2482: NOTICE:  22012
psql:sql/plpgsql.sql:2482: ERROR:  substitute message
CONTEXT:  PL/pgSQL function raise_test() line 7 at RAISE
drop function raise_test();
DROP FUNCTION
-- test passing column_name, constraint_name, datatype_name, table_name
-- and schema_name error fields
create or replace function stacked_diagnostics_test() returns void as $$
declare _column_name text;
        _constraint_name text;
        _datatype_name text;
        _table_name text;
        _schema_name text;
begin
  raise exception using
    column = '>>some column name<<',
    constraint = '>>some constraint name<<',
    datatype = '>>some datatype name<<',
    table = '>>some table name<<',
    schema = '>>some schema name<<';
exception when others then
  get stacked diagnostics
        _column_name = column_name,
        _constraint_name = constraint_name,
        _datatype_name = pg_datatype_name,
        _table_name = table_name,
        _schema_name = schema_name;
  raise notice 'column %, constraint %, type %, table %, schema %',
    _column_name, _constraint_name, _datatype_name, _table_name, _schema_name;
end;
$$ language plpgsql;
CREATE FUNCTION
select stacked_diagnostics_test();
psql:sql/plpgsql.sql:2514: NOTICE:  column >>some column name<<, constraint >>some constraint name<<, type >>some datatype name<<, table >>some table name<<, schema >>some schema name<<
 stacked_diagnostics_test 
--------------------------
 
(1 row)

drop function stacked_diagnostics_test();
DROP FUNCTION
-- in case of conflict, non-variadic version is preferred
create or replace function pleast(numeric)
returns numeric as $$
begin
  raise notice 'non-variadic function called';
  return $1;
end;
$$ language plpgsql immutable strict;
CREATE FUNCTION
select pleast(10);
psql:sql/plpgsql.sql:2528: NOTICE:  non-variadic function called
 pleast 
--------
     10
(1 row)

--drop function pleast(numeric[]);
drop function pleast(numeric);
DROP FUNCTION
-- test table functions
create function tftest(int) returns table(a int, b int) as $$
begin
  return query select $1, $1+i from generate_series(1,5) g(i);
end;
$$ language plpgsql immutable strict;
CREATE FUNCTION
select * from tftest(10);
 a  | b  
----+----
 10 | 11
 10 | 12
 10 | 13
 10 | 14
 10 | 15
(5 rows)

create or replace function tftest(a1 int) returns table(a int, b int) as $$
begin
  a = a1; b = a1 + 1;
  return next;
  a = a1 * 10; b = a1 * 10 + 1;
  return next;
end;
$$ language plpgsql immutable strict;
CREATE FUNCTION
select * from tftest(10);
  a  |  b  
-----+-----
  10 |  11
 100 | 101
(2 rows)

drop function tftest(int);
DROP FUNCTION
create or replace function rttest()
returns setof int as $$
declare rc int;
  rca int[];
begin
  return query values(10),(20);
  get diagnostics rc = row_count;
  raise notice '% %', found, rc;
  return query select * from (values(10),(20)) f(a) where false;
  get diagnostics rc = row_count;
  raise notice '% %', found, rc;
  return query execute 'values(10),(20)';
  -- just for fun, let's use array elements as targets
  get diagnostics rca[1] = row_count;
  raise notice '% %', found, rca[1];
  return query execute 'select * from (values(10),(20)) f(a) where false';
  get diagnostics rca[2] = row_count;
  raise notice '% %', found, rca[2];
end;
$$ language plpgsql;
CREATE FUNCTION
select * from rttest();
psql:sql/plpgsql.sql:2577: NOTICE:  t 2
psql:sql/plpgsql.sql:2577: NOTICE:  f 0
psql:sql/plpgsql.sql:2577: NOTICE:  t 2
psql:sql/plpgsql.sql:2577: NOTICE:  f 0
 rttest 
--------
     10
     20
     10
     20
(4 rows)

drop function rttest();
DROP FUNCTION
-- Test for proper cleanup at subtransaction exit.  This example
-- exposed a bug in PG 8.2.
CREATE FUNCTION leaker_1(fail BOOL) RETURNS INTEGER AS $$
DECLARE
  v_var INTEGER;
BEGIN
  BEGIN
    v_var = (leaker_2(fail)).error_code;
  EXCEPTION
    WHEN others THEN RETURN 0;
  END;
  RETURN 1;
END;
$$ LANGUAGE plpgsql;
CREATE FUNCTION
CREATE FUNCTION leaker_2(fail BOOL, OUT error_code INTEGER, OUT new_id INTEGER)
  RETURNS RECORD AS $$
BEGIN
  IF fail THEN
    RAISE EXCEPTION 'fail ...';
  END IF;
  error_code = 1;
  new_id = 1;
  RETURN;
END;
$$ LANGUAGE plpgsql;
CREATE FUNCTION
SELECT * FROM leaker_1(false);
 leaker_1 
----------
        1
(1 row)

SELECT * FROM leaker_1(true);
 leaker_1 
----------
        0
(1 row)

DROP FUNCTION leaker_1(bool);
DROP FUNCTION
DROP FUNCTION leaker_2(bool);
DROP FUNCTION
-- Test for appropriate cleanup of non-simple expression evaluations
-- (bug in all versions prior to August 2010)
CREATE FUNCTION nonsimple_expr_test() RETURNS text[] AS $$
DECLARE
  arr text[];
  lr text;
  i integer;
BEGIN
  arr = array[array['foo','bar'], array['baz', 'quux']];
  lr = 'fool';
  i = 1;
  -- use sub-SELECTs to make expressions non-simple
  arr[(SELECT i)][(SELECT i+1)] = (SELECT lr);
  RETURN arr;
END;
$$ LANGUAGE plpgsql;
CREATE FUNCTION
SELECT nonsimple_expr_test();
   nonsimple_expr_test   
-------------------------
 {{foo,fool},{baz,quux}}
(1 row)

DROP FUNCTION nonsimple_expr_test();
DROP FUNCTION
CREATE FUNCTION nonsimple_expr_test() RETURNS integer AS $$
declare
   i integer NOT NULL = 0;
begin
  begin
    i = (SELECT NULL::integer);  -- should throw error
  exception
    WHEN OTHERS THEN
      i = (SELECT 1::integer);
  end;
  return i;
end;
$$ LANGUAGE plpgsql;
CREATE FUNCTION
SELECT nonsimple_expr_test();
 nonsimple_expr_test 
---------------------
                   1
(1 row)

DROP FUNCTION nonsimple_expr_test();
DROP FUNCTION
--
-- Test cases involving recursion and error recovery in simple expressions
-- (bugs in all versions before October 2010).  The problems are most
-- easily exposed by mutual recursion between plpgsql and sql functions.
--
create function recurse(float8) returns float8 as
$$
begin
  if ($1 > 0) then
    return sql_recurse($1 - 1);
  else
    return $1;
  end if;
end;
$$ language plpgsql;
CREATE FUNCTION
-- "limit" is to prevent this from being inlined
create function sql_recurse(float8) returns float8 as
$$ select recurse($1) limit 1; $$ language sql;
CREATE FUNCTION
select recurse(10);
 recurse 
---------
       0
(1 row)

create function error1(text) returns text language sql as
$$ SELECT relname::text FROM pg_class c WHERE c.oid = $1::regclass $$;
CREATE FUNCTION
create function error2(p_name_table text) returns text language plpgsql as $$
begin
  return error1(p_name_table);
end$$;
CREATE FUNCTION
--BEGIN;
create table public.stuffs (stuff text);
CREATE TABLE
SAVEPOINT a;
psql:sql/plpgsql.sql:2688: ERROR:  SAVEPOINT can only be used in transaction blocks
select error2('nonexistent.stuffs');
psql:sql/plpgsql.sql:2689: ERROR:  schema "nonexistent" does not exist
CONTEXT:  SQL function "error1" statement 1
PL/pgSQL function error2(text) line 3 at RETURN
ROLLBACK TO a;
psql:sql/plpgsql.sql:2690: ERROR:  ROLLBACK TO SAVEPOINT can only be used in transaction blocks
select error2('public.stuffs');
 error2 
--------
 stuffs
(1 row)

rollback;
psql:sql/plpgsql.sql:2692: WARNING:  there is no transaction in progress
ROLLBACK
drop function error2(p_name_table text);
DROP FUNCTION
drop function error1(text);
DROP FUNCTION
-- Test for proper handling of cast-expression caching
create function sql_to_date(integer) returns date as $$
select $1::text::date
$$ language sql immutable strict;
CREATE FUNCTION
create cast (integer as date) with function sql_to_date(integer) as assignment;
CREATE CAST
create function cast_invoker(integer) returns date as $$
begin
  return $1;
end$$ language plpgsql;
CREATE FUNCTION
select cast_invoker(20150717);
 cast_invoker 
--------------
 2015-07-17
(1 row)

select cast_invoker(20150718);  -- second call crashed in pre-release 9.5
 cast_invoker 
--------------
 2015-07-18
(1 row)

begin;
BEGIN
select cast_invoker(20150717);
 cast_invoker 
--------------
 2015-07-17
(1 row)

select cast_invoker(20150718);
 cast_invoker 
--------------
 2015-07-18
(1 row)

savepoint s1;
SAVEPOINT
select cast_invoker(20150718);
 cast_invoker 
--------------
 2015-07-18
(1 row)

select cast_invoker(-1); -- fails
psql:sql/plpgsql.sql:2718: ERROR:  invalid input syntax for type date: "-1"
CONTEXT:  SQL function "sql_to_date" statement 1
PL/pgSQL function cast_invoker(integer) while casting return value to function's return type
rollback to savepoint s1;
ROLLBACK
select cast_invoker(20150719);
 cast_invoker 
--------------
 2015-07-19
(1 row)

select cast_invoker(20150720);
 cast_invoker 
--------------
 2015-07-20
(1 row)

commit;
COMMIT
drop function cast_invoker(integer);
DROP FUNCTION
drop function sql_to_date(integer) cascade;
psql:sql/plpgsql.sql:2725: NOTICE:  drop cascades to cast from integer to date
DROP FUNCTION
-- Test handling of cast cache inside DO blocks
-- (to check the original crash case, this must be a cast not previously
-- used in this session)
begin;
BEGIN
do $$ declare x text[]; begin x = '{1.23, 4.56}'::numeric[]; end $$;
DO
do $$ declare x text[]; begin x = '{1.23, 4.56}'::numeric[]; end $$;
DO
end;
COMMIT
-- Test for consistent reporting of error context
create function fail() returns int language plpgsql as $$
begin
  return 1/0;
end
$$;
CREATE FUNCTION
select fail();
psql:sql/plpgsql.sql:2744: ERROR:  division by zero
CONTEXT:  SQL statement "SELECT 1/0"
PL/pgSQL function fail() line 3 at RETURN
select fail();
psql:sql/plpgsql.sql:2745: ERROR:  division by zero
CONTEXT:  SQL statement "SELECT 1/0"
PL/pgSQL function fail() line 3 at RETURN
drop function fail();
DROP FUNCTION
-- Test handling of string literals.
set standard_conforming_strings = off;
SET
create or replace function strtest() returns text as $$
begin
  raise notice 'foo\\bar\041baz';
  return 'foo\\bar\041baz';
end
$$ language plpgsql;
psql:sql/plpgsql.sql:2758: WARNING:  nonstandard use of \\ in a string literal
LINE 3:   raise notice 'foo\\bar\041baz';
                       ^
HINT:  Use the escape string syntax for backslashes, e.g., E'\\'.
psql:sql/plpgsql.sql:2758: WARNING:  nonstandard use of \\ in a string literal
LINE 4:   return 'foo\\bar\041baz';
                 ^
HINT:  Use the escape string syntax for backslashes, e.g., E'\\'.
psql:sql/plpgsql.sql:2758: WARNING:  nonstandard use of \\ in a string literal
LINE 4:   return 'foo\\bar\041baz';
                 ^
HINT:  Use the escape string syntax for backslashes, e.g., E'\\'.
CREATE FUNCTION
select strtest();
psql:sql/plpgsql.sql:2760: NOTICE:  foo\bar!baz
psql:sql/plpgsql.sql:2760: WARNING:  nonstandard use of \\ in a string literal
LINE 1: SELECT 'foo\\bar\041baz'
               ^
HINT:  Use the escape string syntax for backslashes, e.g., E'\\'.
QUERY:  SELECT 'foo\\bar\041baz'
   strtest   
-------------
 foo\bar!baz
(1 row)

create or replace function strtest() returns text as $$
begin
  raise notice E'foo\\bar\041baz';
  return E'foo\\bar\041baz';
end
$$ language plpgsql;
CREATE FUNCTION
select strtest();
psql:sql/plpgsql.sql:2769: NOTICE:  foo\bar!baz
   strtest   
-------------
 foo\bar!baz
(1 row)

set standard_conforming_strings = on;
SET
create or replace function strtest() returns text as $$
begin
  raise notice 'foo\\bar\041baz\';
  return 'foo\\bar\041baz\';
end
$$ language plpgsql;
CREATE FUNCTION
select strtest();
psql:sql/plpgsql.sql:2780: NOTICE:  foo\\bar\041baz\
     strtest      
------------------
 foo\\bar\041baz\
(1 row)

create or replace function strtest() returns text as $$
begin
  raise notice E'foo\\bar\041baz';
  return E'foo\\bar\041baz';
end
$$ language plpgsql;
CREATE FUNCTION
select strtest();
psql:sql/plpgsql.sql:2789: NOTICE:  foo\bar!baz
   strtest   
-------------
 foo\bar!baz
(1 row)

drop function strtest();
DROP FUNCTION
-- Test anonymous code blocks.
DO $$
DECLARE r record;
BEGIN
    FOR r IN SELECT rtrim(roomno) AS roomno, comment FROM Room ORDER BY roomno
    LOOP
        RAISE NOTICE '%, %', r.roomno, r.comment;
    END LOOP;
END$$;
psql:sql/plpgsql.sql:2802: NOTICE:  001, Entrance
psql:sql/plpgsql.sql:2802: NOTICE:  002, Office
psql:sql/plpgsql.sql:2802: NOTICE:  003, Office
psql:sql/plpgsql.sql:2802: NOTICE:  004, Technical
psql:sql/plpgsql.sql:2802: NOTICE:  101, Office
psql:sql/plpgsql.sql:2802: NOTICE:  102, Conference
psql:sql/plpgsql.sql:2802: NOTICE:  103, Restroom
psql:sql/plpgsql.sql:2802: NOTICE:  104, Technical
psql:sql/plpgsql.sql:2802: NOTICE:  105, Office
psql:sql/plpgsql.sql:2802: NOTICE:  106, Office
DO
-- these are to check syntax error reporting
DO LANGUAGE plpgsql $$begin return 1; end$$;
psql:sql/plpgsql.sql:2805: ERROR:  RETURN cannot have a parameter in function returning void
LINE 1: DO LANGUAGE plpgsql $$begin return 1; end$$;
                                           ^
DO $$
DECLARE r record;
BEGIN
    FOR r IN SELECT rtrim(roomno) AS roomno, foo FROM Room ORDER BY roomno
    LOOP
        RAISE NOTICE '%, %', r.roomno, r.comment;
    END LOOP;
END$$;
psql:sql/plpgsql.sql:2814: ERROR:  column "foo" does not exist
LINE 1: SELECT rtrim(roomno) AS roomno, foo FROM Room ORDER BY roomn...
                                        ^
QUERY:  SELECT rtrim(roomno) AS roomno, foo FROM Room ORDER BY roomno
CONTEXT:  PL/pgSQL function inline_code_block line 4 at FOR over SELECT rows
-- Check handling of errors thrown from/into anonymous code blocks.
do $outer$
--begin
  for i in 1..10 loop
   begin
    execute $ex$
      do $$
      declare x int = 0;
      begin
        x = 1 / x;
      end;
      $$;
    $ex$;
  exception when division_by_zero then
    raise notice 'caught division by zero';
  end;
  end loop;
end;
$outer$;
psql:sql/plpgsql.sql:2834: ERROR:  syntax error at or near "for"
LINE 3:   for i in 1..10 loop
          ^
-- Check variable scoping -- a var is not available in its own or prior
-- default expressions.
create function scope_test() returns int as $$
declare x int = 42;
begin
  declare y int = x + 1;
          x int = x + 2;
  begin
    return x * 100 + y;
  end;
end;
$$ language plpgsql;
CREATE FUNCTION
select scope_test();
 scope_test 
------------
       4443
(1 row)

drop function scope_test();
DROP FUNCTION
-- Check handling of conflicts between plpgsql vars and table columns.
set plpgsql.variable_conflict = error;
SET
create function conflict_test() returns setof int8_tbl as $$
declare r record;
  q1 bigint = 42;
begin
  for r in select q1,q2 from int8_tbl loop
    return next r;
  end loop;
end;
$$ language plpgsql;
CREATE FUNCTION
select * from conflict_test();
psql:sql/plpgsql.sql:2868: ERROR:  column reference "q1" is ambiguous
LINE 1: select q1,q2 from int8_tbl
               ^
DETAIL:  It could refer to either a PL/pgSQL variable or a table column.
QUERY:  select q1,q2 from int8_tbl
CONTEXT:  PL/pgSQL function conflict_test() line 5 at FOR over SELECT rows
create or replace function conflict_test() returns setof int8_tbl as $$
#variable_conflict use_variable
declare r record;
  q1 bigint = 42;
begin
  for r in select q1,q2 from int8_tbl loop
    return next r;
  end loop;
end;
$$ language plpgsql;
CREATE FUNCTION
select * from conflict_test();
 q1 |        q2         
----+-------------------
 42 |               456
 42 |  4567890123456789
 42 |               123
 42 |  4567890123456789
 42 | -4567890123456789
(5 rows)

create or replace function conflict_test() returns setof int8_tbl as $$
#variable_conflict use_column
declare r record;
  q1 bigint = 42;
begin
  for r in select q1,q2 from int8_tbl loop
    return next r;
  end loop;
end;
$$ language plpgsql;
CREATE FUNCTION
select * from conflict_test();
        q1        |        q2         
------------------+-------------------
              123 |               456
              123 |  4567890123456789
 4567890123456789 |               123
 4567890123456789 |  4567890123456789
 4567890123456789 | -4567890123456789
(5 rows)

drop function conflict_test();
DROP FUNCTION
-- Check that an unreserved keyword can be used as a variable name
create function unreserved_test() returns int as $$
declare
  forward int = 21;
begin
  forward = forward * 2;
  return forward;
end
$$ language plpgsql;
CREATE FUNCTION
select unreserved_test();
 unreserved_test 
-----------------
              42
(1 row)

create or replace function unreserved_test() returns int as $$
declare
  return int = 42;
begin
  return = return + 1;
  return return;
end
$$ language plpgsql;
CREATE FUNCTION
select unreserved_test();
 unreserved_test 
-----------------
              43
(1 row)

drop function unreserved_test();
DROP FUNCTION
--
-- Test FOREACH over arrays
--
create function foreach_test(anyarray)
returns void as $$
declare x int;
begin
  foreach x in array $1
  loop
    raise notice '%', x;
  end loop;
  end;
$$ language plpgsql;
CREATE FUNCTION
select foreach_test(ARRAY[1,2,3,4]);
psql:sql/plpgsql.sql:2939: NOTICE:  1
psql:sql/plpgsql.sql:2939: NOTICE:  2
psql:sql/plpgsql.sql:2939: NOTICE:  3
psql:sql/plpgsql.sql:2939: NOTICE:  4
 foreach_test 
--------------
 
(1 row)

select foreach_test(ARRAY[[1,2],[3,4]]);
psql:sql/plpgsql.sql:2940: NOTICE:  1
psql:sql/plpgsql.sql:2940: NOTICE:  2
psql:sql/plpgsql.sql:2940: NOTICE:  3
psql:sql/plpgsql.sql:2940: NOTICE:  4
 foreach_test 
--------------
 
(1 row)

create or replace function foreach_test(anyarray)
returns void as $$
declare x int;
begin
  foreach x slice 1 in array $1
  loop
    raise notice '%', x;
  end loop;
  end;
$$ language plpgsql;
CREATE FUNCTION
-- should fail
select foreach_test(ARRAY[1,2,3,4]);
psql:sql/plpgsql.sql:2954: ERROR:  FOREACH ... SLICE loop variable must be of an array type
CONTEXT:  PL/pgSQL function foreach_test(anyarray) line 4 at FOREACH over array
select foreach_test(ARRAY[[1,2],[3,4]]);
psql:sql/plpgsql.sql:2955: ERROR:  FOREACH ... SLICE loop variable must be of an array type
CONTEXT:  PL/pgSQL function foreach_test(anyarray) line 4 at FOREACH over array
create or replace function foreach_test(anyarray)
returns void as $$
declare x int[];
begin
  foreach x slice 1 in array $1
  loop
    raise notice '%', x;
  end loop;
  end;
$$ language plpgsql;
CREATE FUNCTION
select foreach_test(ARRAY[1,2,3,4]);
psql:sql/plpgsql.sql:2968: NOTICE:  {1,2,3,4}
 foreach_test 
--------------
 
(1 row)

select foreach_test(ARRAY[[1,2],[3,4]]);
psql:sql/plpgsql.sql:2969: NOTICE:  {1,2}
psql:sql/plpgsql.sql:2969: NOTICE:  {3,4}
 foreach_test 
--------------
 
(1 row)

-- higher level of slicing
create or replace function foreach_test(anyarray)
returns void as $$
declare x int[];
begin
  foreach x slice 2 in array $1
  loop
    raise notice '%', x;
  end loop;
  end;
$$ language plpgsql;
CREATE FUNCTION
-- should fail
select foreach_test(ARRAY[1,2,3,4]);
psql:sql/plpgsql.sql:2984: ERROR:  slice dimension (2) is out of the valid range 0..1
CONTEXT:  PL/pgSQL function foreach_test(anyarray) line 4 at FOREACH over array
-- ok
select foreach_test(ARRAY[[1,2],[3,4]]);
psql:sql/plpgsql.sql:2986: NOTICE:  {{1,2},{3,4}}
 foreach_test 
--------------
 
(1 row)

select foreach_test(ARRAY[[[1,2]],[[3,4]]]);
psql:sql/plpgsql.sql:2987: NOTICE:  {{1,2}}
psql:sql/plpgsql.sql:2987: NOTICE:  {{3,4}}
 foreach_test 
--------------
 
(1 row)

create type xy_tuple AS (x int, y int);
CREATE TYPE
-- iteration over array of records
create or replace function foreach_test(anyarray)
returns void as $$
declare r record;
begin
  foreach r in array $1
  loop
    raise notice '%', r;
  end loop;
  end;
$$ language plpgsql;
CREATE FUNCTION
select foreach_test(ARRAY[(10,20),(40,69),(35,78)]::xy_tuple[]);
psql:sql/plpgsql.sql:3003: NOTICE:  (10,20)
psql:sql/plpgsql.sql:3003: NOTICE:  (40,69)
psql:sql/plpgsql.sql:3003: NOTICE:  (35,78)
 foreach_test 
--------------
 
(1 row)

select foreach_test(ARRAY[[(10,20),(40,69)],[(35,78),(88,76)]]::xy_tuple[]);
psql:sql/plpgsql.sql:3004: NOTICE:  (10,20)
psql:sql/plpgsql.sql:3004: NOTICE:  (40,69)
psql:sql/plpgsql.sql:3004: NOTICE:  (35,78)
psql:sql/plpgsql.sql:3004: NOTICE:  (88,76)
 foreach_test 
--------------
 
(1 row)

create or replace function foreach_test(anyarray)
returns void as $$
declare x int; y int;
begin
  foreach x, y in array $1
  loop
    raise notice 'x = %, y = %', x, y;
  end loop;
  end;
$$ language plpgsql;
CREATE FUNCTION
select foreach_test(ARRAY[(10,20),(40,69),(35,78)]::xy_tuple[]);
psql:sql/plpgsql.sql:3017: NOTICE:  x = 10, y = 20
psql:sql/plpgsql.sql:3017: NOTICE:  x = 40, y = 69
psql:sql/plpgsql.sql:3017: NOTICE:  x = 35, y = 78
 foreach_test 
--------------
 
(1 row)

select foreach_test(ARRAY[[(10,20),(40,69)],[(35,78),(88,76)]]::xy_tuple[]);
psql:sql/plpgsql.sql:3018: NOTICE:  x = 10, y = 20
psql:sql/plpgsql.sql:3018: NOTICE:  x = 40, y = 69
psql:sql/plpgsql.sql:3018: NOTICE:  x = 35, y = 78
psql:sql/plpgsql.sql:3018: NOTICE:  x = 88, y = 76
 foreach_test 
--------------
 
(1 row)

-- slicing over array of composite types
create or replace function foreach_test(anyarray)
returns void as $$
declare x xy_tuple[];
begin
  foreach x slice 1 in array $1
  loop
    raise notice '%', x;
  end loop;
  end;
$$ language plpgsql;
CREATE FUNCTION
select foreach_test(ARRAY[(10,20),(40,69),(35,78)]::xy_tuple[]);
psql:sql/plpgsql.sql:3032: NOTICE:  {"(10,20)","(40,69)","(35,78)"}
 foreach_test 
--------------
 
(1 row)

select foreach_test(ARRAY[[(10,20),(40,69)],[(35,78),(88,76)]]::xy_tuple[]);
psql:sql/plpgsql.sql:3033: NOTICE:  {"(10,20)","(40,69)"}
psql:sql/plpgsql.sql:3033: NOTICE:  {"(35,78)","(88,76)"}
 foreach_test 
--------------
 
(1 row)

drop function foreach_test(anyarray);
DROP FUNCTION
drop type xy_tuple;
DROP TYPE
--
-- Assorted tests for array subscript assignment
--
create temp table rtype (id int, ar text[]);
CREATE TABLE
create function arrayassign1() returns text[] language plpgsql as $$
declare
 r record;
begin
  r = row(12, '{foo,bar,baz}')::rtype;
  r.ar[2] = 'replace';
  return r.ar;
end$$;
CREATE FUNCTION
select arrayassign1();
   arrayassign1    
-------------------
 {foo,replace,baz}
(1 row)

select arrayassign1(); -- try again to exercise internal caching
   arrayassign1    
-------------------
 {foo,replace,baz}
(1 row)

--
-- Test handling of expanded arrays
--
create function returns_rw_array(int) returns int[]
language plpgsql as $$
  declare r int[];
  begin r = array[$1, $1]; return r; end;
$$ stable;
CREATE FUNCTION
create function consumes_rw_array(int[]) returns int
language plpgsql as $$
  begin return $1[1]; end;
$$ stable;
CREATE FUNCTION
select consumes_rw_array(returns_rw_array(42));
 consumes_rw_array 
-------------------
                42
(1 row)

-- bug #14174
explain (verbose, costs off)
select i, a from
  (select returns_rw_array(1) as a offset 0) ss,
  lateral consumes_rw_array(a) i;

select i, a from
  (select returns_rw_array(1) as a offset 0) ss,
  lateral consumes_rw_array(a) i;
 i |   a   
---+-------
 1 | {1,1}
(1 row)

explain (verbose, costs off)
select consumes_rw_array(a), a from returns_rw_array(1) a;

select consumes_rw_array(a), a from returns_rw_array(1) a;
 consumes_rw_array |   a   
-------------------+-------
                 1 | {1,1}
(1 row)

explain (verbose, costs off)
select consumes_rw_array(a), a from
  (values (returns_rw_array(1)), (returns_rw_array(2))) v(a);

select consumes_rw_array(a), a from
  (values (returns_rw_array(1)), (returns_rw_array(2))) v(a);
 consumes_rw_array |   a   
-------------------+-------
                 1 | {1,1}
                 2 | {2,2}
(2 rows)

do $$
declare a int[] = array[1,2];
begin
  a = a || 3;
  raise notice 'a = %', a;
end$$;
psql:sql/plpgsql.sql:3100: NOTICE:  a = {1,2,3}
DO
--
-- Test access to call stack
--
create function inner_func(int)
returns int as $$
declare _context text;
begin
  get diagnostics _context = pg_context;
  raise notice '***%***', _context;
  -- lets do it again, just for fun..
  get diagnostics _context = pg_context;
  raise notice '***%***', _context;
  raise notice 'lets make sure we didnt break anything';
  return 2 * $1;
end;
$$ language plpgsql;
CREATE FUNCTION
create or replace function outer_func(int)
returns int as $$
declare
  myresult int;
begin
  raise notice 'calling down into inner_func()';
  myresult = inner_func($1);
  raise notice 'inner_func() done';
  return myresult;
end;
$$ language plpgsql;
CREATE FUNCTION
create or replace function outer_outer_func(int)
returns int as $$
declare
  myresult int;
begin
  raise notice 'calling down into outer_func()';
  myresult = outer_func($1);
  raise notice 'outer_func() done';
  return myresult;
end;
$$ language plpgsql;
CREATE FUNCTION
select outer_outer_func(10);
psql:sql/plpgsql.sql:3145: NOTICE:  calling down into outer_func()
psql:sql/plpgsql.sql:3145: NOTICE:  calling down into inner_func()
psql:sql/plpgsql.sql:3145: NOTICE:  ***PL/pgSQL function inner_func(integer) line 4 at GET DIAGNOSTICS
PL/pgSQL function outer_func(integer) line 6 at assignment
PL/pgSQL function outer_outer_func(integer) line 6 at assignment***
psql:sql/plpgsql.sql:3145: NOTICE:  ***PL/pgSQL function inner_func(integer) line 7 at GET DIAGNOSTICS
PL/pgSQL function outer_func(integer) line 6 at assignment
PL/pgSQL function outer_outer_func(integer) line 6 at assignment***
psql:sql/plpgsql.sql:3145: NOTICE:  lets make sure we didnt break anything
psql:sql/plpgsql.sql:3145: NOTICE:  inner_func() done
psql:sql/plpgsql.sql:3145: NOTICE:  outer_func() done
 outer_outer_func 
------------------
               20
(1 row)

-- repeated call should to work
select outer_outer_func(20);
psql:sql/plpgsql.sql:3147: NOTICE:  calling down into outer_func()
psql:sql/plpgsql.sql:3147: NOTICE:  calling down into inner_func()
psql:sql/plpgsql.sql:3147: NOTICE:  ***PL/pgSQL function inner_func(integer) line 4 at GET DIAGNOSTICS
PL/pgSQL function outer_func(integer) line 6 at assignment
PL/pgSQL function outer_outer_func(integer) line 6 at assignment***
psql:sql/plpgsql.sql:3147: NOTICE:  ***PL/pgSQL function inner_func(integer) line 7 at GET DIAGNOSTICS
PL/pgSQL function outer_func(integer) line 6 at assignment
PL/pgSQL function outer_outer_func(integer) line 6 at assignment***
psql:sql/plpgsql.sql:3147: NOTICE:  lets make sure we didnt break anything
psql:sql/plpgsql.sql:3147: NOTICE:  inner_func() done
psql:sql/plpgsql.sql:3147: NOTICE:  outer_func() done
 outer_outer_func 
------------------
               40
(1 row)

drop function outer_outer_func(int);
DROP FUNCTION
drop function outer_func(int);
DROP FUNCTION
drop function inner_func(int);
DROP FUNCTION
-- access to call stack from exception
create function inner_func(int)
returns int as $$
declare
  _context text;
  sx int = 5;
begin
  begin
    perform sx / 0;
  exception
    when division_by_zero then
      get diagnostics _context = pg_context;
      raise notice '***%***', _context;
  end;

  -- lets do it again, just for fun..
  get diagnostics _context = pg_context;
  raise notice '***%***', _context;
  raise notice 'lets make sure we didnt break anything';
  return 2 * $1;
end;
$$ language plpgsql;
CREATE FUNCTION
create or replace function outer_func(int)
returns int as $$
declare
  myresult int;
begin
  raise notice 'calling down into inner_func()';
  myresult = inner_func($1);
  raise notice 'inner_func() done';
  return myresult;
end;
$$ language plpgsql;
CREATE FUNCTION
create or replace function outer_outer_func(int)
returns int as $$
declare
  myresult int;
begin
  raise notice 'calling down into outer_func()';
  myresult = outer_func($1);
  raise notice 'outer_func() done';
  return myresult;
end;
$$ language plpgsql;
CREATE FUNCTION
select outer_outer_func(10);
psql:sql/plpgsql.sql:3200: NOTICE:  calling down into outer_func()
psql:sql/plpgsql.sql:3200: NOTICE:  calling down into inner_func()
psql:sql/plpgsql.sql:3200: NOTICE:  ***PL/pgSQL function inner_func(integer) line 10 at GET DIAGNOSTICS
PL/pgSQL function outer_func(integer) line 6 at assignment
PL/pgSQL function outer_outer_func(integer) line 6 at assignment***
psql:sql/plpgsql.sql:3200: NOTICE:  ***PL/pgSQL function inner_func(integer) line 15 at GET DIAGNOSTICS
PL/pgSQL function outer_func(integer) line 6 at assignment
PL/pgSQL function outer_outer_func(integer) line 6 at assignment***
psql:sql/plpgsql.sql:3200: NOTICE:  lets make sure we didnt break anything
psql:sql/plpgsql.sql:3200: NOTICE:  inner_func() done
psql:sql/plpgsql.sql:3200: NOTICE:  outer_func() done
 outer_outer_func 
------------------
               20
(1 row)

-- repeated call should to work
select outer_outer_func(20);
psql:sql/plpgsql.sql:3202: NOTICE:  calling down into outer_func()
psql:sql/plpgsql.sql:3202: NOTICE:  calling down into inner_func()
psql:sql/plpgsql.sql:3202: NOTICE:  ***PL/pgSQL function inner_func(integer) line 10 at GET DIAGNOSTICS
PL/pgSQL function outer_func(integer) line 6 at assignment
PL/pgSQL function outer_outer_func(integer) line 6 at assignment***
psql:sql/plpgsql.sql:3202: NOTICE:  ***PL/pgSQL function inner_func(integer) line 15 at GET DIAGNOSTICS
PL/pgSQL function outer_func(integer) line 6 at assignment
PL/pgSQL function outer_outer_func(integer) line 6 at assignment***
psql:sql/plpgsql.sql:3202: NOTICE:  lets make sure we didnt break anything
psql:sql/plpgsql.sql:3202: NOTICE:  inner_func() done
psql:sql/plpgsql.sql:3202: NOTICE:  outer_func() done
 outer_outer_func 
------------------
               40
(1 row)

drop function outer_outer_func(int);
DROP FUNCTION
drop function outer_func(int);
DROP FUNCTION
drop function inner_func(int);
DROP FUNCTION
--
-- Test ASSERT
--
do $$
begin
  assert 1=1;  -- should succeed
end;
$$;
DO
do $$
begin
  assert 1=0;  -- should fail
end;
$$;
psql:sql/plpgsql.sql:3222: ERROR:  assertion failed
CONTEXT:  PL/pgSQL function inline_code_block line 3 at ASSERT
do $$
begin
  assert NULL;  -- should fail
end;
$$;
psql:sql/plpgsql.sql:3228: ERROR:  assertion failed
CONTEXT:  PL/pgSQL function inline_code_block line 3 at ASSERT
-- check controlling GUC
set plpgsql.check_asserts = off;
SET
do $$
begin
  assert 1=0;  -- won't be tested
end;
$$;
DO
reset plpgsql.check_asserts;
RESET
-- test custom message
do $$
declare var text = 'some value';
begin
  assert 1=0, format('assertion failed, var = "%s"', var);
end;
$$;
psql:sql/plpgsql.sql:3245: ERROR:  assertion failed, var = "some value"
CONTEXT:  PL/pgSQL function inline_code_block line 4 at ASSERT
-- ensure assertions are not trapped by 'others'
do $$
begin
  assert 1=0, 'unhandled assertion';
exception when others then
  null; -- do nothing
end;
$$;
psql:sql/plpgsql.sql:3254: ERROR:  unhandled assertion
CONTEXT:  PL/pgSQL function inline_code_block line 3 at ASSERT
--
-- test usage of transition tables in AFTER triggers
--
CREATE TABLE transition_table_base (id int PRIMARY KEY, val text);
CREATE TABLE
--CREATE TRIGGER transition_table_base_ins_trig
--  AFTER INSERT ON transition_table_base
--  REFERENCING OLD TABLE AS oldtable NEW TABLE AS newtable
--  FOR EACH STATEMENT
--  EXECUTE PROCEDURE transition_table_base_ins_func();
--CREATE TRIGGER transition_table_base_ins_trig
--  AFTER INSERT ON transition_table_base
--  REFERENCING NEW TABLE AS newtable
--  FOR EACH STATEMENT
--  EXECUTE PROCEDURE transition_table_base_ins_func();
INSERT INTO transition_table_base VALUES (1, 'One'), (2, 'Two');
INSERT 0 2
INSERT INTO transition_table_base VALUES (3, 'Three'), (4, 'Four');
INSERT 0 2
--CREATE TRIGGER transition_table_base_upd_trig
--  AFTER UPDATE ON transition_table_base
--  REFERENCING OLD TABLE AS oldtable NEW TABLE AS newtable
--  FOR EACH STATEMENT
-- EXECUTE PROCEDURE transition_table_base_upd_func();
UPDATE transition_table_base
  SET val = '*' || val || '*'
  WHERE id BETWEEN 2 AND 3;
UPDATE 2
  
CREATE TABLE transition_table_level1
(
      level1_no serial NOT NULL ,
      level1_node_name varchar(255),
       PRIMARY KEY (level1_no)
) WITHOUT OIDS;
CREATE TABLE
CREATE TABLE transition_table_level2
(
      level2_no serial NOT NULL ,
      parent_no int NOT NULL,
      level1_node_name varchar(255),
       PRIMARY KEY (level2_no)
) WITHOUT OIDS;
CREATE TABLE
CREATE TABLE transition_table_status
(
      level int NOT NULL,
      node_no int NOT NULL,
      status int,
       PRIMARY KEY (level, node_no)
) WITHOUT OIDS;
CREATE TABLE
--CREATE TRIGGER transition_table_level1_ri_parent_del_trigger
--  AFTER DELETE ON transition_table_level1
--  REFERENCING OLD TABLE AS p
--  FOR EACH STATEMENT EXECUTE PROCEDURE
--    transition_table_level1_ri_parent_del_func();
--CREATE TRIGGER transition_table_level1_ri_parent_upd_trigger
--  AFTER UPDATE ON transition_table_level1
--  REFERENCING OLD TABLE AS d NEW TABLE AS i
--  FOR EACH STATEMENT EXECUTE PROCEDURE
--    transition_table_level1_ri_parent_upd_func();
--CREATE TRIGGER transition_table_level2_ri_child_ins_trigger
--  AFTER INSERT ON transition_table_level2
--  REFERENCING NEW TABLE AS i
--  FOR EACH STATEMENT EXECUTE PROCEDURE
--    transition_table_level2_ri_child_insupd_func();
--CREATE TRIGGER transition_table_level2_ri_child_upd_trigger
--  AFTER UPDATE ON transition_table_level2
--  REFERENCING NEW TABLE AS i
--  FOR EACH STATEMENT EXECUTE PROCEDURE
--    transition_table_level2_ri_child_insupd_func();
-- create initial test data
INSERT INTO transition_table_level1 (level1_no)
  SELECT generate_series(1,200);
INSERT 0 200
--ANALYZE transition_table_level1;
INSERT INTO transition_table_level2 (level2_no, parent_no)
  SELECT level2_no, level2_no / 50 + 1 AS parent_no
    FROM generate_series(1,9999) level2_no;
INSERT 0 9999
--ANALYZE transition_table_level2;
INSERT INTO transition_table_status (level, node_no, status)
  SELECT 1, level1_no, 0 FROM transition_table_level1;
INSERT 0 200
INSERT INTO transition_table_status (level, node_no, status)
  SELECT 2, level2_no, 0 FROM transition_table_level2;
INSERT 0 9999
--ANALYZE transition_table_status;
INSERT INTO transition_table_level1(level1_no)
  SELECT generate_series(201,1000);
INSERT 0 800
--ANALYZE transition_table_level1;
-- behave reasonably if someone tries to modify a transition table
--CREATE TRIGGER transition_table_level2_bad_usage_trigger
--  AFTER DELETE ON transition_table_level2
--  REFERENCING OLD TABLE AS dx
--  FOR EACH STATEMENT EXECUTE PROCEDURE
--   transition_table_level2_bad_usage_func();
DELETE FROM transition_table_level2
  WHERE level2_no BETWEEN 301 AND 305;
DELETE 5
--DROP TRIGGER transition_table_level2_bad_usage_trigger
--  ON transition_table_level2;
-- attempt modifications which would break RI (should all fail)
DELETE FROM transition_table_level1
  WHERE level1_no = 25;
DELETE 1
UPDATE transition_table_level1 SET level1_no = -1
  WHERE level1_no = 30;
UPDATE 1
INSERT INTO transition_table_level2 (level2_no, parent_no)
  VALUES (10000, 10000);
INSERT 0 1
UPDATE transition_table_level2 SET parent_no = 2000
  WHERE level2_no = 40;
UPDATE 1
-- attempt modifications which would not break RI (should all succeed)
DELETE FROM transition_table_level1
  WHERE level1_no BETWEEN 201 AND 1000;
DELETE 800
DELETE FROM transition_table_level1
  WHERE level1_no BETWEEN 100000000 AND 100000010;
DELETE 0
SELECT count(*) FROM transition_table_level1;
 count 
-------
   199
(1 row)

DELETE FROM transition_table_level2
  WHERE level2_no BETWEEN 211 AND 220;
DELETE 10
SELECT count(*) FROM transition_table_level2;
 count 
-------
  9985
(1 row)

CREATE TABLE alter_table_under_transition_tables
(
  id int PRIMARY KEY,
  name text
);
CREATE TABLE
-- should fail, TRUNCATE is not compatible with transition tables
--CREATE TRIGGER alter_table_under_transition_tables_upd_trigger
--  AFTER TRUNCATE OR UPDATE ON alter_table_under_transition_tables
--  REFERENCING OLD TABLE AS d NEW TABLE AS i
--  FOR EACH STATEMENT EXECUTE PROCEDURE
 --   alter_table_under_transition_tables_upd_func();
-- should work
--CREATE TRIGGER alter_table_under_transition_tables_upd_trigger
--  AFTER UPDATE ON alter_table_under_transition_tables
--  REFERENCING OLD TABLE AS d NEW TABLE AS i
--  FOR EACH STATEMENT EXECUTE PROCEDURE
--    alter_table_under_transition_tables_upd_func();
INSERT INTO alter_table_under_transition_tables
  VALUES (1, '1'), (2, '2'), (3, '3');
INSERT 0 3
UPDATE alter_table_under_transition_tables
  SET name = name || name;
UPDATE 3
-- now change 'name' to an integer to see what happens...
ALTER TABLE alter_table_under_transition_tables
  ALTER COLUMN name TYPE int USING name::integer;
ALTER TABLE
UPDATE alter_table_under_transition_tables
  SET name = (name::text || name::text)::integer;
UPDATE 3
-- now drop column 'name'
ALTER TABLE alter_table_under_transition_tables
  DROP column name;
ALTER TABLE
UPDATE alter_table_under_transition_tables
  SET id = id;
UPDATE 0
--
-- Test multiple reference to a transition table
--
CREATE TABLE multi_test (i int);
CREATE TABLE
INSERT INTO multi_test VALUES (1);
INSERT 0 1
--CREATE TRIGGER my_trigger AFTER UPDATE ON multi_test
--  REFERENCING NEW TABLE AS new_test OLD TABLE as old_test
--  FOR EACH STATEMENT EXECUTE PROCEDURE multi_test_trig();
--UPDATE multi_test SET i = i;
DROP TABLE multi_test;
DROP TABLE
DROP FUNCTION multi_test_trig();
psql:sql/plpgsql.sql:3450: ERROR:  function multi_test_trig() does not exist
--
-- Check type parsing and record fetching from partitioned tables
--
CREATE TABLE partitioned_table (a int, b text) PARTITION BY LIST (a);
CREATE TABLE
CREATE TABLE pt_part1 PARTITION OF partitioned_table FOR VALUES IN (1);
CREATE TABLE
CREATE TABLE pt_part2 PARTITION OF partitioned_table FOR VALUES IN (2);
CREATE TABLE
INSERT INTO partitioned_table VALUES (1, 'Row 1');
INSERT 0 1
INSERT INTO partitioned_table VALUES (2, 'Row 2');
INSERT 0 1
CREATE OR REPLACE FUNCTION get_from_partitioned_table(partitioned_table.a%type)
RETURNS partitioned_table AS $$
DECLARE
    a_val partitioned_table.a%TYPE;
    result partitioned_table%ROWTYPE;
BEGIN
    a_val = $1;
    SELECT * INTO result FROM partitioned_table WHERE a = a_val;
    RETURN result;
END; $$ LANGUAGE plpgsql;
psql:sql/plpgsql.sql:3472: NOTICE:  type reference partitioned_table.a%TYPE converted to integer
CREATE FUNCTION
SELECT * FROM get_from_partitioned_table(1) AS t;
 a |   b   
---+-------
 1 | Row 1
(1 row)

CREATE OR REPLACE FUNCTION list_partitioned_table()
RETURNS SETOF partitioned_table.a%TYPE AS $$
DECLARE
    row partitioned_table%ROWTYPE;
    a_val partitioned_table.a%TYPE;
BEGIN
    FOR row IN SELECT * FROM partitioned_table ORDER BY a LOOP
        a_val = row.a;
        RETURN NEXT a_val;
    END LOOP;
    RETURN;
END; $$ LANGUAGE plpgsql;
psql:sql/plpgsql.sql:3487: NOTICE:  type reference partitioned_table.a%TYPE converted to integer
CREATE FUNCTION
SELECT * FROM list_partitioned_table() AS t;
 t 
---
 1
 2
(2 rows)

--
-- Check argument name is used instead of $n in error message
--
CREATE FUNCTION fx(x WSlot) RETURNS void AS $$
BEGIN
  GET DIAGNOSTICS x = ROW_COUNT;
  RETURN;
END; $$ LANGUAGE plpgsql;
psql:sql/plpgsql.sql:3498: ERROR:  "x" is not a scalar variable
LINE 3:   GET DIAGNOSTICS x = ROW_COUNT;
                          ^
