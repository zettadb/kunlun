--
-- Test access privileges
--
-- Clean up in case a prior regression run failed
-- Suppress NOTICE messages when users/groups don't exist
SET client_min_messages TO 'warning';
SET
DROP ROLE IF EXISTS regress_priv_group1;
DROP ROLE
DROP ROLE IF EXISTS regress_priv_group2;
DROP ROLE
DROP ROLE IF EXISTS regress_priv_user1;
DROP ROLE
DROP ROLE IF EXISTS regress_priv_user2;
DROP ROLE
DROP ROLE IF EXISTS regress_priv_user3;
DROP ROLE
DROP ROLE IF EXISTS regress_priv_user4;
DROP ROLE
DROP ROLE IF EXISTS regress_priv_user5;
DROP ROLE
DROP ROLE IF EXISTS regress_priv_user6;
DROP ROLE
RESET client_min_messages;
RESET
-- test proper begins here
CREATE USER regress_priv_user1;
CREATE ROLE
CREATE USER regress_priv_user2;
CREATE ROLE
CREATE USER regress_priv_user3;
CREATE ROLE
CREATE USER regress_priv_user4;
CREATE ROLE
CREATE USER regress_priv_user5;
CREATE ROLE
CREATE USER regress_priv_user5;	-- duplicate
psql:sql/privileges.sql:29: ERROR:  role "regress_priv_user5" already exists
CREATE GROUP regress_priv_group1;
CREATE ROLE
CREATE GROUP regress_priv_group2 WITH USER regress_priv_user1, regress_priv_user2;
CREATE ROLE
ALTER GROUP regress_priv_group1 ADD USER regress_priv_user4;
ALTER ROLE
ALTER GROUP regress_priv_group2 ADD USER regress_priv_user2;	-- duplicate
psql:sql/privileges.sql:36: NOTICE:  role "regress_priv_user2" is already a member of role "regress_priv_group2"
ALTER ROLE
ALTER GROUP regress_priv_group2 DROP USER regress_priv_user2;
ALTER ROLE
GRANT regress_priv_group2 TO regress_priv_user4 WITH ADMIN OPTION;
GRANT ROLE
-- test owner privileges
SET SESSION AUTHORIZATION regress_priv_user1;
SET
SELECT session_user, current_user;
    session_user    |    current_user    
--------------------+--------------------
 regress_priv_user1 | regress_priv_user1
(1 row)

DROP TABLE if exists atest1;
psql:sql/privileges.sql:45: NOTICE:  table "atest1" does not exist, skipping
DROP TABLE
CREATE TABLE atest1 ( a int, b text );
CREATE TABLE
SELECT * FROM atest1;
 a | b 
---+---
(0 rows)

INSERT INTO atest1 VALUES (1, 'one');
INSERT 0 1
DELETE FROM atest1;
DELETE 1
UPDATE atest1 SET a = 1 WHERE b = 'blech';
UPDATE 0
delete from atest1;
DELETE 0
BEGIN;
BEGIN
LOCK atest1 IN ACCESS EXCLUSIVE MODE;
LOCK TABLE
COMMIT;
COMMIT
REVOKE ALL ON atest1 FROM PUBLIC;
REVOKE
SELECT * FROM atest1;
 a | b 
---+---
(0 rows)

GRANT ALL ON atest1 TO regress_priv_user2;
GRANT
GRANT SELECT ON atest1 TO regress_priv_user3, regress_priv_user4;
GRANT
SELECT * FROM atest1;
 a | b 
---+---
(0 rows)

drop table if exists atest2;
psql:sql/privileges.sql:63: NOTICE:  table "atest2" does not exist, skipping
DROP TABLE
CREATE TABLE atest2 (col1 varchar(10), col2 boolean);
CREATE TABLE
GRANT SELECT ON atest2 TO regress_priv_user2;
GRANT
GRANT UPDATE ON atest2 TO regress_priv_user3;
GRANT
GRANT INSERT ON atest2 TO regress_priv_user4;
GRANT
SET SESSION AUTHORIZATION regress_priv_user2;
SET
SELECT session_user, current_user;
    session_user    |    current_user    
--------------------+--------------------
 regress_priv_user2 | regress_priv_user2
(1 row)

-- try various combinations of queries on atest1 and atest2
SELECT * FROM atest1; -- ok
 a | b 
---+---
(0 rows)

SELECT * FROM atest2; -- ok
 col1 | col2 
------+------
(0 rows)

INSERT INTO atest1 VALUES (2, 'two'); -- ok
INSERT 0 1
INSERT INTO atest2 VALUES ('foo', true); -- fail
psql:sql/privileges.sql:78: ERROR:  permission denied for table atest2
INSERT INTO atest1 SELECT 1, b FROM atest1; -- ok
INSERT 0 1
UPDATE atest1 SET a = 1 WHERE a = 2; -- ok
UPDATE 1
UPDATE atest2 SET col2 = NOT col2; -- fail
psql:sql/privileges.sql:81: ERROR:  permission denied for table atest2
DELETE FROM atest2; -- fail
psql:sql/privileges.sql:82: ERROR:  permission denied for table atest2
delete from atest2; -- fail
psql:sql/privileges.sql:83: ERROR:  permission denied for table atest2
BEGIN;
BEGIN
LOCK atest2 IN ACCESS EXCLUSIVE MODE; -- fail
psql:sql/privileges.sql:85: ERROR:  permission denied for table atest2
COMMIT;
ROLLBACK
COPY atest2 FROM stdin; -- fail
psql:sql/privileges.sql:87: ERROR:  permission denied for table atest2
GRANT ALL ON atest1 TO PUBLIC; -- fail
psql:sql/privileges.sql:89: WARNING:  no privileges were granted for "atest1"
GRANT
-- checks in subquery, both ok
SELECT * FROM atest1 WHERE ( b IN ( SELECT col1 FROM atest2 ) );
 a | b 
---+---
(0 rows)

SELECT * FROM atest2 WHERE ( col1 IN ( SELECT b FROM atest1 ) );
 col1 | col2 
------+------
(0 rows)

SET SESSION AUTHORIZATION regress_priv_user3;
SET
SELECT session_user, current_user;
    session_user    |    current_user    
--------------------+--------------------
 regress_priv_user3 | regress_priv_user3
(1 row)

SELECT * FROM atest1; -- ok
 a |  b  
---+-----
 1 | two
 1 | two
(2 rows)

SELECT * FROM atest2; -- fail
psql:sql/privileges.sql:100: ERROR:  permission denied for table atest2
INSERT INTO atest1 VALUES (2, 'two'); -- fail
psql:sql/privileges.sql:101: ERROR:  permission denied for table atest1
INSERT INTO atest2 VALUES ('foo', true); -- fail
psql:sql/privileges.sql:102: ERROR:  permission denied for table atest2
INSERT INTO atest1 SELECT 1, b FROM atest1; -- fail
psql:sql/privileges.sql:103: ERROR:  permission denied for table atest1
UPDATE atest1 SET a = 1 WHERE a = 2; -- fail
psql:sql/privileges.sql:104: ERROR:  permission denied for table atest1
UPDATE atest2 SET col2 = NULL; -- ok
UPDATE 0
UPDATE atest2 SET col2 = NOT col2; -- fails; requires SELECT on atest2
psql:sql/privileges.sql:106: ERROR:  permission denied for table atest2
delete from atest2; -- fail
psql:sql/privileges.sql:107: ERROR:  permission denied for table atest2
BEGIN;
BEGIN
LOCK atest2 IN ACCESS EXCLUSIVE MODE; -- ok
LOCK TABLE
COMMIT;
COMMIT
COPY atest2 FROM stdin; -- fail
psql:sql/privileges.sql:111: ERROR:  permission denied for table atest2
-- checks in subquery, both fail
SELECT * FROM atest1 WHERE ( b IN ( SELECT col1 FROM atest2 ) );
psql:sql/privileges.sql:114: ERROR:  permission denied for table atest2
SELECT * FROM atest2 WHERE ( col1 IN ( SELECT b FROM atest1 ) );
psql:sql/privileges.sql:115: ERROR:  permission denied for table atest2
SET SESSION AUTHORIZATION regress_priv_user4;
SET
COPY atest2 FROM stdin; -- ok
COPY 1
SELECT * FROM atest1; -- ok
 a |  b  
---+-----
 1 | two
 1 | two
(2 rows)

-- test leaky-function protections in selfuncs
-- regress_priv_user1 will own a table and provide views for it.
SET SESSION AUTHORIZATION regress_priv_user1;
SET
drop table if exists atest12;
psql:sql/privileges.sql:129: NOTICE:  table "atest12" does not exist, skipping
DROP TABLE
create table atest12(a int, b int);
CREATE TABLE
insert into atest12 SELECT x AS a, 10001 - x AS b FROM generate_series(1,10000) x;
INSERT 0 10000
CREATE INDEX ON atest12 (a);
CREATE INDEX
CREATE FUNCTION leak(integer,integer) RETURNS boolean
  AS $$begin return $1 < $2; end$$
  LANGUAGE plpgsql immutable;
CREATE FUNCTION
CREATE OPERATOR <<< (procedure = leak, leftarg = integer, rightarg = integer,
                     restrict = scalarltsel);
CREATE OPERATOR
-- views with leaky operator
CREATE VIEW atest12v AS
  SELECT * FROM atest12 WHERE b <<< 5;
CREATE VIEW
CREATE VIEW atest12sbv AS
  SELECT * FROM atest12 WHERE b <<< 5;
CREATE VIEW
GRANT SELECT ON atest12v TO PUBLIC;
GRANT
GRANT SELECT ON atest12sbv TO PUBLIC;
GRANT
-- This plan should use nestloop, knowing that few rows will be selected.
EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y WHERE x.a = y.b;

-- And this one.
EXPLAIN (COSTS OFF) SELECT * FROM atest12 x, atest12 y
  WHERE x.a = y.b and abs(y.a) <<< 5;

-- This should also be a nestloop, but the security barrier forces the inner
-- scan to be materialized
EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y WHERE x.a = y.b;

-- Check if regress_priv_user2 can break security.
SET SESSION AUTHORIZATION regress_priv_user2;
SET
CREATE FUNCTION leak2(integer,integer) RETURNS boolean
  AS $$begin raise notice 'leak % %', $1, $2; return $1 > $2; end$$
  LANGUAGE plpgsql immutable;
CREATE FUNCTION
CREATE OPERATOR >>> (procedure = leak2, leftarg = integer, rightarg = integer,
                     restrict = scalargtsel);
CREATE OPERATOR
-- This should not show any "leak" notices before failing.
EXPLAIN (COSTS OFF) SELECT * FROM atest12 WHERE a >>> 0;
psql:sql/privileges.sql:169: ERROR:  permission denied for table atest12
-- These plans should continue to use a nestloop, since they execute with the
-- privileges of the view owner.
EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y WHERE x.a = y.b;

EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y WHERE x.a = y.b;

-- A non-security barrier view does not guard against information leakage.
EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y
  WHERE x.a = y.b and abs(y.a) <<< 5;

-- But a security barrier view isolates the leaky operator.
EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y
  WHERE x.a = y.b and abs(y.a) <<< 5;

-- Now regress_priv_user1 grants sufficient access to regress_priv_user2.
SET SESSION AUTHORIZATION regress_priv_user1;
SET
GRANT SELECT (a, b) ON atest12 TO PUBLIC;
GRANT
SET SESSION AUTHORIZATION regress_priv_user2;
SET
-- regress_priv_user2 should continue to get a good row estimate.
EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y WHERE x.a = y.b;

-- But not for this, due to lack of table-wide permissions needed
-- to make use of the expression index's statistics.
EXPLAIN (COSTS OFF) SELECT * FROM atest12 x, atest12 y
  WHERE x.a = y.b and abs(y.a) <<< 5;

-- clean up (regress_priv_user1's objects are all dropped later)
DROP FUNCTION leak2(integer, integer) CASCADE;
psql:sql/privileges.sql:198: NOTICE:  drop cascades to operator >>>(integer,integer)
DROP FUNCTION
-- groups
SET SESSION AUTHORIZATION regress_priv_user3;
SET
drop table if exists atest3;
psql:sql/privileges.sql:205: NOTICE:  table "atest3" does not exist, skipping
DROP TABLE
CREATE TABLE atest3 (one int, two int, three int);
CREATE TABLE
GRANT DELETE ON atest3 TO GROUP regress_priv_group2;
GRANT
SET SESSION AUTHORIZATION regress_priv_user1;
SET
SELECT * FROM atest3; -- fail
psql:sql/privileges.sql:211: ERROR:  permission denied for table atest3
DELETE FROM atest3; -- ok
DELETE 0
-- views
SET SESSION AUTHORIZATION regress_priv_user3;
SET
CREATE VIEW atestv1 AS SELECT * FROM atest1; -- ok
CREATE VIEW
/* The next *should* fail, but it's not implemented that way yet. */
CREATE VIEW atestv2 AS SELECT * FROM atest2;
CREATE VIEW
CREATE VIEW atestv3 AS SELECT * FROM atest3; -- ok
CREATE VIEW
/* Empty view is a corner case that failed in 9.2. */
CREATE VIEW atestv0 AS SELECT 0 as x WHERE false; -- ok
CREATE VIEW
SELECT * FROM atestv1; -- ok
 a |  b  
---+-----
 1 | two
 1 | two
(2 rows)

SELECT * FROM atestv2; -- fail
psql:sql/privileges.sql:227: ERROR:  permission denied for table atest2
GRANT SELECT ON atestv1, atestv3 TO regress_priv_user4;
GRANT
GRANT SELECT ON atestv2 TO regress_priv_user2;
GRANT
SET SESSION AUTHORIZATION regress_priv_user4;
SET
SELECT * FROM atestv1; -- ok
 a |  b  
---+-----
 1 | two
 1 | two
(2 rows)

SELECT * FROM atestv2; -- fail
psql:sql/privileges.sql:233: ERROR:  permission denied for view atestv2
SELECT * FROM atestv3; -- ok
 one | two | three 
-----+-----+-------
(0 rows)

SELECT * FROM atestv0; -- fail
psql:sql/privileges.sql:235: ERROR:  permission denied for view atestv0
-- Appendrels excluded by constraints failed to check permissions in 8.4-9.2.
select * from
  ((select a.q1 as x from int8_tbl a offset 0)
   union all
   (select b.q2 as x from int8_tbl b offset 0)) ss
where false;
psql:sql/privileges.sql:242: ERROR:  permission denied for table int8_tbl
set constraint_exclusion = on;
SET
select * from
  ((select a.q1 as x, random() from int8_tbl a where q1 > 0)
   union all
   (select b.q2 as x, random() from int8_tbl b where q2 > 0)) ss
where x < 0;
psql:sql/privileges.sql:249: ERROR:  permission denied for table int8_tbl
reset constraint_exclusion;
RESET
CREATE VIEW atestv4 AS SELECT * FROM atestv3; -- nested view
CREATE VIEW
SELECT * FROM atestv4; -- ok
 one | two | three 
-----+-----+-------
(0 rows)

GRANT SELECT ON atestv4 TO regress_priv_user2;
GRANT
SET SESSION AUTHORIZATION regress_priv_user2;
SET
-- Two complex cases:
SELECT * FROM atestv3; -- fail
psql:sql/privileges.sql:260: ERROR:  permission denied for view atestv3
SELECT * FROM atestv4; -- ok (even though regress_priv_user2 cannot access underlying atestv3)
 one | two | three 
-----+-----+-------
(0 rows)

SELECT * FROM atest2; -- ok
 col1 | col2 
------+------
 bar  | t
(1 row)

SELECT * FROM atestv2; -- fail (even though regress_priv_user2 can access underlying atest2)
psql:sql/privileges.sql:264: ERROR:  permission denied for table atest2
-- Test column level permissions
SET SESSION AUTHORIZATION regress_priv_user1;
SET
drop table if exists atest5;
psql:sql/privileges.sql:269: NOTICE:  table "atest5" does not exist, skipping
DROP TABLE
CREATE TABLE atest5 (one int, two int unique, three int, four int unique);
CREATE TABLE
drop table if exists atest6;
psql:sql/privileges.sql:271: NOTICE:  table "atest6" does not exist, skipping
DROP TABLE
CREATE TABLE atest6 (one int, two int, blue int);
CREATE TABLE
GRANT SELECT (one), INSERT (two), UPDATE (three) ON atest5 TO regress_priv_user4;
GRANT
GRANT ALL (one) ON atest5 TO regress_priv_user3;
GRANT
INSERT INTO atest5 VALUES (1,2,3);
INSERT 0 1
SET SESSION AUTHORIZATION regress_priv_user4;
SET
SELECT * FROM atest5; -- fail
psql:sql/privileges.sql:279: ERROR:  permission denied for table atest5
SELECT one FROM atest5; -- ok
 one 
-----
   1
(1 row)

COPY atest5 (one) TO stdout; -- ok
1
SELECT two FROM atest5; -- fail
psql:sql/privileges.sql:282: ERROR:  permission denied for table atest5
COPY atest5 (two) TO stdout; -- fail
psql:sql/privileges.sql:283: ERROR:  permission denied for table atest5
SELECT atest5 FROM atest5; -- fail
psql:sql/privileges.sql:284: ERROR:  permission denied for table atest5
COPY atest5 (one,two) TO stdout; -- fail
psql:sql/privileges.sql:285: ERROR:  permission denied for table atest5
SELECT 1 FROM atest5; -- ok
 ?column? 
----------
        1
(1 row)

SELECT 1 FROM atest5 a JOIN atest5 b USING (one); -- ok
 ?column? 
----------
        1
(1 row)

SELECT 1 FROM atest5 a JOIN atest5 b USING (two); -- fail
psql:sql/privileges.sql:288: ERROR:  permission denied for table atest5
SELECT 1 FROM atest5 a NATURAL JOIN atest5 b; -- fail
psql:sql/privileges.sql:289: ERROR:  permission denied for table atest5
SELECT (j.*) IS NULL FROM (atest5 a JOIN atest5 b USING (one)) j; -- fail
psql:sql/privileges.sql:290: ERROR:  permission denied for table atest5
SELECT 1 FROM atest5 WHERE two = 2; -- fail
psql:sql/privileges.sql:291: ERROR:  permission denied for table atest5
SELECT * FROM atest1, atest5; -- fail
psql:sql/privileges.sql:292: ERROR:  permission denied for table atest5
SELECT atest1.* FROM atest1, atest5; -- ok
 a |  b  
---+-----
 1 | two
 1 | two
(2 rows)

SELECT atest1.*,atest5.one FROM atest1, atest5; -- ok
 a |  b  | one 
---+-----+-----
 1 | two |   1
 1 | two |   1
(2 rows)

SELECT atest1.*,atest5.one FROM atest1 JOIN atest5 ON (atest1.a = atest5.two); -- fail
psql:sql/privileges.sql:295: ERROR:  permission denied for table atest5
SELECT atest1.*,atest5.one FROM atest1 JOIN atest5 ON (atest1.a = atest5.one); -- ok
 a |  b  | one 
---+-----+-----
 1 | two |   1
 1 | two |   1
(2 rows)

SELECT one, two FROM atest5; -- fail
psql:sql/privileges.sql:297: ERROR:  permission denied for table atest5
SET SESSION AUTHORIZATION regress_priv_user1;
SET
GRANT SELECT (one,two) ON atest6 TO regress_priv_user4;
GRANT
SET SESSION AUTHORIZATION regress_priv_user4;
SET
SELECT one, two FROM atest5 NATURAL JOIN atest6; -- fail still
psql:sql/privileges.sql:303: ERROR:  permission denied for table atest5
SET SESSION AUTHORIZATION regress_priv_user1;
SET
GRANT SELECT (two) ON atest5 TO regress_priv_user4;
GRANT
SET SESSION AUTHORIZATION regress_priv_user4;
SET
SELECT one, two FROM atest5 NATURAL JOIN atest6; -- ok now
 one | two 
-----+-----
(0 rows)

-- test column-level privileges for INSERT and UPDATE
INSERT INTO atest5 (two) VALUES (3); -- ok
INSERT 0 1
COPY atest5 FROM stdin; -- fail
psql:sql/privileges.sql:313: ERROR:  permission denied for table atest5
COPY atest5 (two) FROM stdin; -- ok
COPY 1
INSERT INTO atest5 (three) VALUES (4); -- fail
psql:sql/privileges.sql:317: ERROR:  permission denied for table atest5
INSERT INTO atest5 VALUES (5,5,5); -- fail
psql:sql/privileges.sql:318: ERROR:  permission denied for table atest5
UPDATE atest5 SET three = 10; -- ok
UPDATE 3
UPDATE atest5 SET one = 8; -- fail
psql:sql/privileges.sql:320: ERROR:  permission denied for table atest5
UPDATE atest5 SET three = 5, one = 2; -- fail
psql:sql/privileges.sql:321: ERROR:  permission denied for table atest5
-- Check that column level privs are enforced in RETURNING
-- Check that the columns in the inference require select privileges
INSERT INTO atest5(four) VALUES (4); -- fail
psql:sql/privileges.sql:325: ERROR:  permission denied for table atest5
SET SESSION AUTHORIZATION regress_priv_user1;
SET
GRANT INSERT (four) ON atest5 TO regress_priv_user4;
GRANT
SET SESSION AUTHORIZATION regress_priv_user4;
SET
INSERT INTO atest5(four) VALUES (4); -- ok
INSERT 0 1
SET SESSION AUTHORIZATION regress_priv_user1;
SET
GRANT SELECT (four) ON atest5 TO regress_priv_user4;
GRANT
SET SESSION AUTHORIZATION regress_priv_user4;
SET
SET SESSION AUTHORIZATION regress_priv_user1;
SET
REVOKE ALL (one) ON atest5 FROM regress_priv_user4;
REVOKE
GRANT SELECT (one,two,blue) ON atest6 TO regress_priv_user4;
GRANT
SET SESSION AUTHORIZATION regress_priv_user4;
SET
SELECT one FROM atest5; -- fail
psql:sql/privileges.sql:342: ERROR:  permission denied for table atest5
UPDATE atest5 SET one = 1; -- fail
psql:sql/privileges.sql:343: ERROR:  permission denied for table atest5
SELECT atest6 FROM atest6; -- ok
 atest6 
--------
(0 rows)

COPY atest6 TO stdout; -- ok
-- check error reporting with column privs
SET SESSION AUTHORIZATION regress_priv_user1;
SET
drop table if exists t1;
psql:sql/privileges.sql:349: NOTICE:  table "t1" does not exist, skipping
DROP TABLE
CREATE TABLE t1 (c1 int, c2 int, c3 int, primary key (c1, c2));
CREATE TABLE
GRANT SELECT (c1) ON t1 TO regress_priv_user2;
GRANT
GRANT INSERT (c1, c2, c3) ON t1 TO regress_priv_user2;
GRANT
GRANT UPDATE (c1, c2, c3) ON t1 TO regress_priv_user2;
GRANT
-- seed data
INSERT INTO t1 VALUES (1, 1, 1);
INSERT 0 1
INSERT INTO t1 VALUES (1, 2, 1);
INSERT 0 1
INSERT INTO t1 VALUES (2, 1, 2);
INSERT 0 1
INSERT INTO t1 VALUES (2, 2, 2);
INSERT 0 1
INSERT INTO t1 VALUES (3, 1, 3);
INSERT 0 1
SET SESSION AUTHORIZATION regress_priv_user2;
SET
INSERT INTO t1 (c1, c2) VALUES (1, 1); -- fail, but row not shown
psql:sql/privileges.sql:363: ERROR:  Kunlun-db: MySQL storage node (1, 1) returned error: 1062, Duplicate entry '1-1' for key 't1.PRIMARY'.
UPDATE t1 SET c2 = 1; -- fail, but row not shown
psql:sql/privileges.sql:364: ERROR:  Kunlun-db: MySQL storage node (1, 1) returned error: 1062, Duplicate entry '1-1' for key 't1.PRIMARY'.
INSERT INTO t1 (c1, c2) VALUES (null, null); -- fail, but see columns being inserted
psql:sql/privileges.sql:365: ERROR:  null value in column "c1" violates not-null constraint
DETAIL:  Failing row contains (c1, c2) = (null, null).
INSERT INTO t1 (c3) VALUES (null); -- fail, but see columns being inserted or have SELECT
psql:sql/privileges.sql:366: ERROR:  null value in column "c1" violates not-null constraint
DETAIL:  Failing row contains (c1, c3) = (null, null).
INSERT INTO t1 (c1) VALUES (5); -- fail, but see columns being inserted or have SELECT
psql:sql/privileges.sql:367: ERROR:  null value in column "c2" violates not-null constraint
DETAIL:  Failing row contains (c1) = (5).
UPDATE t1 SET c3 = 10; -- fail, but see columns with SELECT rights, or being modified
UPDATE 5
SET SESSION AUTHORIZATION regress_priv_user1;
SET
DROP TABLE t1;
DROP TABLE
-- test column-level privileges when involved with DELETE
SET SESSION AUTHORIZATION regress_priv_user1;
SET
ALTER TABLE atest6 ADD COLUMN three integer;
ALTER TABLE
GRANT DELETE ON atest5 TO regress_priv_user3;
GRANT
GRANT SELECT (two) ON atest5 TO regress_priv_user3;
GRANT
REVOKE ALL (one) ON atest5 FROM regress_priv_user3;
REVOKE
GRANT SELECT (one) ON atest5 TO regress_priv_user4;
GRANT
SET SESSION AUTHORIZATION regress_priv_user4;
SET
SELECT atest6 FROM atest6; -- fail
psql:sql/privileges.sql:382: ERROR:  permission denied for table atest6
SELECT one FROM atest5 NATURAL JOIN atest6; -- fail
psql:sql/privileges.sql:383: ERROR:  permission denied for table atest5
SET SESSION AUTHORIZATION regress_priv_user1;
SET
ALTER TABLE atest6 DROP COLUMN three;
ALTER TABLE
SET SESSION AUTHORIZATION regress_priv_user4;
SET
SELECT one FROM atest5 NATURAL JOIN atest6; -- ok
 one 
-----
(0 rows)

SET SESSION AUTHORIZATION regress_priv_user1;
SET
ALTER TABLE atest6 DROP COLUMN two;
ALTER TABLE
REVOKE SELECT (one,blue) ON atest6 FROM regress_priv_user4;
REVOKE
SET SESSION AUTHORIZATION regress_priv_user4;
SET
SELECT * FROM atest6; -- fail
psql:sql/privileges.sql:396: ERROR:  permission denied for table atest6
SELECT 1 FROM atest6; -- fail
psql:sql/privileges.sql:397: ERROR:  permission denied for table atest6
SET SESSION AUTHORIZATION regress_priv_user3;
SET
DELETE FROM atest5 WHERE one = 1; -- fail
psql:sql/privileges.sql:400: ERROR:  permission denied for table atest5
DELETE FROM atest5 WHERE two = 2; -- ok
DELETE 1
-- privileges on functions, languages
-- switch to superuser
\c -
You are now connected to database "regress" as user "abc".
REVOKE ALL PRIVILEGES ON LANGUAGE sql FROM PUBLIC;
REVOKE
GRANT USAGE ON LANGUAGE sql TO regress_priv_user1; -- 
GRANT
GRANT USAGE ON LANGUAGE c TO PUBLIC; -- fail
psql:sql/privileges.sql:410: ERROR:  language "c" is not trusted
DETAIL:  GRANT and REVOKE are not allowed on untrusted languages, because only superusers can use untrusted languages.
SET SESSION AUTHORIZATION regress_priv_user1;
SET
GRANT USAGE ON LANGUAGE sql TO regress_priv_user2; -- fail
psql:sql/privileges.sql:413: WARNING:  no privileges were granted for "sql"
GRANT
CREATE FUNCTION priv_testfunc1(int) RETURNS int AS 'select 2 * $1;' LANGUAGE sql;
CREATE FUNCTION
CREATE FUNCTION priv_testfunc2(int) RETURNS int AS 'select 3 * $1;' LANGUAGE sql;
CREATE FUNCTION
CREATE AGGREGATE priv_testagg1(int) (sfunc = int4pl, stype = int4);
CREATE AGGREGATE
CREATE PROCEDURE priv_testproc1(int) AS 'select $1;' LANGUAGE sql;
CREATE PROCEDURE
REVOKE ALL ON FUNCTION priv_testfunc1(int), priv_testfunc2(int), priv_testagg1(int) FROM PUBLIC;
REVOKE
GRANT EXECUTE ON FUNCTION priv_testfunc1(int), priv_testfunc2(int), priv_testagg1(int) TO regress_priv_user2;
GRANT
REVOKE ALL ON FUNCTION priv_testproc1(int) FROM PUBLIC; -- fail, not a function
psql:sql/privileges.sql:421: ERROR:  priv_testproc1(integer) is not a function
REVOKE ALL ON PROCEDURE priv_testproc1(int) FROM PUBLIC;
REVOKE
GRANT EXECUTE ON PROCEDURE priv_testproc1(int) TO regress_priv_user2;
GRANT
GRANT USAGE ON FUNCTION priv_testfunc1(int) TO regress_priv_user3; -- semantic error
psql:sql/privileges.sql:424: ERROR:  invalid privilege type USAGE for function
GRANT USAGE ON FUNCTION priv_testagg1(int) TO regress_priv_user3; -- semantic error
psql:sql/privileges.sql:425: ERROR:  invalid privilege type USAGE for function
GRANT USAGE ON PROCEDURE priv_testproc1(int) TO regress_priv_user3; -- semantic error
psql:sql/privileges.sql:426: ERROR:  invalid privilege type USAGE for procedure
GRANT ALL PRIVILEGES ON FUNCTION priv_testfunc1(int) TO regress_priv_user4;
GRANT
GRANT ALL PRIVILEGES ON FUNCTION priv_testfunc_nosuch(int) TO regress_priv_user4;
psql:sql/privileges.sql:428: ERROR:  function priv_testfunc_nosuch(integer) does not exist
GRANT ALL PRIVILEGES ON FUNCTION priv_testagg1(int) TO regress_priv_user4;
GRANT
GRANT ALL PRIVILEGES ON PROCEDURE priv_testproc1(int) TO regress_priv_user4;
GRANT
CREATE FUNCTION priv_testfunc4(boolean) RETURNS text
  AS 'select col1 from atest2 where col2 = $1;'
  LANGUAGE sql SECURITY DEFINER;
CREATE FUNCTION
GRANT EXECUTE ON FUNCTION priv_testfunc4(boolean) TO regress_priv_user3;
GRANT
SET SESSION AUTHORIZATION regress_priv_user2;
SET
SELECT priv_testfunc1(5), priv_testfunc2(5); -- ok
 priv_testfunc1 | priv_testfunc2 
----------------+----------------
             10 |             15
(1 row)

CREATE FUNCTION priv_testfunc3(int) RETURNS int AS 'select 2 * $1;' LANGUAGE sql; -- fail
psql:sql/privileges.sql:439: ERROR:  permission denied for language sql
SELECT priv_testagg1(x) FROM (VALUES (1), (2), (3)) _(x); -- ok
 priv_testagg1 
---------------
             6
(1 row)

CALL priv_testproc1(6); -- ok
CALL
SET SESSION AUTHORIZATION regress_priv_user3;
SET
SELECT priv_testfunc1(5); -- fail
psql:sql/privileges.sql:444: ERROR:  permission denied for function priv_testfunc1
SELECT priv_testagg1(x) FROM (VALUES (1), (2), (3)) _(x); -- fail
psql:sql/privileges.sql:445: ERROR:  permission denied for aggregate priv_testagg1
CALL priv_testproc1(6); -- fail
psql:sql/privileges.sql:446: ERROR:  permission denied for procedure priv_testproc1
SELECT col1 FROM atest2 WHERE col2 = true; -- fail
psql:sql/privileges.sql:447: ERROR:  permission denied for table atest2
SELECT priv_testfunc4(true); -- ok
 priv_testfunc4 
----------------
 bar
(1 row)

SET SESSION AUTHORIZATION regress_priv_user4;
SET
SELECT priv_testfunc1(5); -- ok
 priv_testfunc1 
----------------
             10
(1 row)

SELECT priv_testagg1(x) FROM (VALUES (1), (2), (3)) _(x); -- ok
 priv_testagg1 
---------------
             6
(1 row)

CALL priv_testproc1(6); -- ok
CALL
DROP FUNCTION priv_testfunc1(int); -- fail
psql:sql/privileges.sql:455: ERROR:  must be owner of function priv_testfunc1
DROP AGGREGATE priv_testagg1(int); -- fail
psql:sql/privileges.sql:456: ERROR:  must be owner of aggregate priv_testagg1
DROP PROCEDURE priv_testproc1(int); -- fail
psql:sql/privileges.sql:457: ERROR:  must be owner of procedure priv_testproc1
\c -
You are now connected to database "regress" as user "abc".
DROP FUNCTION priv_testfunc1(int); -- ok
DROP FUNCTION
-- restore to sanity
GRANT ALL PRIVILEGES ON LANGUAGE sql TO PUBLIC;
GRANT
-- verify privilege checks on array-element coercions
BEGIN;
BEGIN
SELECT '{1}'::int4[]::int8[];
 int8 
------
 {1}
(1 row)

REVOKE ALL ON FUNCTION int8(integer) FROM PUBLIC;
REVOKE
SELECT '{1}'::int4[]::int8[]; --superuser, suceed
 int8 
------
 {1}
(1 row)

SET SESSION AUTHORIZATION regress_priv_user4;
SET
SELECT '{1}'::int4[]::int8[]; --other user, fail
psql:sql/privileges.sql:471: ERROR:  permission denied for function int8
ROLLBACK;
ROLLBACK
-- privileges on types
-- switch to superuser
\c -
You are now connected to database "regress" as user "abc".
SET SESSION AUTHORIZATION regress_priv_user5;
SET
delete from atest2; -- ok
psql:sql/privileges.sql:480: ERROR:  permission denied for table atest2
delete from atest3; -- fail
psql:sql/privileges.sql:481: ERROR:  permission denied for table atest3
-- has_table_privilege function
-- bad-input checks
select has_table_privilege(NULL,'pg_authid','select');
 has_table_privilege 
---------------------
 
(1 row)

select has_table_privilege('pg_shad','select');
psql:sql/privileges.sql:487: ERROR:  relation "pg_shad" does not exist
select has_table_privilege('nosuchuser','pg_authid','select');
psql:sql/privileges.sql:488: ERROR:  role "nosuchuser" does not exist
select has_table_privilege('pg_authid','sel');
psql:sql/privileges.sql:489: ERROR:  unrecognized privilege type: "sel"
select has_table_privilege(-999999,'pg_authid','update');
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege(1,'select');
 has_table_privilege 
---------------------
 
(1 row)

-- superuser
\c -
You are now connected to database "regress" as user "abc".
select has_table_privilege(current_user,'pg_authid','select');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege(current_user,'pg_authid','insert');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege(t2.oid,'pg_authid','update')
from (select oid from pg_roles where rolname = current_user) as t2;
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege(t2.oid,'pg_authid','delete')
from (select oid from pg_roles where rolname = current_user) as t2;
 has_table_privilege 
---------------------
 t
(1 row)

-- 'rule' privilege no longer exists, but for backwards compatibility
-- has_table_privilege still recognizes the keyword and says FALSE
select has_table_privilege(current_user,t1.oid,'rule')
from (select oid from pg_class where relname = 'pg_authid') as t1;
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege(current_user,t1.oid,'references')
from (select oid from pg_class where relname = 'pg_authid') as t1;
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege(t2.oid,t1.oid,'select')
from (select oid from pg_class where relname = 'pg_authid') as t1,
  (select oid from pg_roles where rolname = current_user) as t2;
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege(t2.oid,t1.oid,'insert')
from (select oid from pg_class where relname = 'pg_authid') as t1,
  (select oid from pg_roles where rolname = current_user) as t2;
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('pg_authid','update');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('pg_authid','delete');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege(t1.oid,'select')
from (select oid from pg_class where relname = 'pg_authid') as t1;
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege(t1.oid,'trigger')
from (select oid from pg_class where relname = 'pg_authid') as t1;
 has_table_privilege 
---------------------
 t
(1 row)

-- non-superuser
SET SESSION AUTHORIZATION regress_priv_user3;
SET
select has_table_privilege(current_user,'pg_class','select');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege(current_user,'pg_class','insert');
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege(t2.oid,'pg_class','update')
from (select oid from pg_roles where rolname = current_user) as t2;
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege(t2.oid,'pg_class','delete')
from (select oid from pg_roles where rolname = current_user) as t2;
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege(current_user,t1.oid,'references')
from (select oid from pg_class where relname = 'pg_class') as t1;
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege(t2.oid,t1.oid,'select')
from (select oid from pg_class where relname = 'pg_class') as t1,
  (select oid from pg_roles where rolname = current_user) as t2;
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege(t2.oid,t1.oid,'insert')
from (select oid from pg_class where relname = 'pg_class') as t1,
  (select oid from pg_roles where rolname = current_user) as t2;
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege('pg_class','update');
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege('pg_class','delete');
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege(t1.oid,'select')
from (select oid from pg_class where relname = 'pg_class') as t1;
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege(t1.oid,'trigger')
from (select oid from pg_class where relname = 'pg_class') as t1;
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege(current_user,'atest1','select');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege(current_user,'atest1','insert');
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege(t2.oid,'atest1','update')
from (select oid from pg_roles where rolname = current_user) as t2;
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege(t2.oid,'atest1','delete')
from (select oid from pg_roles where rolname = current_user) as t2;
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege(current_user,t1.oid,'references')
from (select oid from pg_class where relname = 'atest1') as t1;
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege(t2.oid,t1.oid,'select')
from (select oid from pg_class where relname = 'atest1') as t1,
  (select oid from pg_roles where rolname = current_user) as t2;
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege(t2.oid,t1.oid,'insert')
from (select oid from pg_class where relname = 'atest1') as t1,
  (select oid from pg_roles where rolname = current_user) as t2;
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege('atest1','update');
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege('atest1','delete');
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege(t1.oid,'select')
from (select oid from pg_class where relname = 'atest1') as t1;
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege(t1.oid,'trigger')
from (select oid from pg_class where relname = 'atest1') as t1;
 has_table_privilege 
---------------------
 f
(1 row)

-- has_column_privilege function
-- bad-input checks (as non-super-user)
select has_column_privilege('pg_authid',NULL,'select');
 has_column_privilege 
----------------------
 
(1 row)

select has_column_privilege('pg_authid','nosuchcol','select');
psql:sql/privileges.sql:585: ERROR:  column "nosuchcol" of relation "pg_authid" does not exist
select has_column_privilege(9999,'nosuchcol','select');
 has_column_privilege 
----------------------
 
(1 row)

select has_column_privilege(9999,99::int2,'select');
 has_column_privilege 
----------------------
 
(1 row)

select has_column_privilege('pg_authid',99::int2,'select');
 has_column_privilege 
----------------------
 
(1 row)

select has_column_privilege(9999,99::int2,'select');
 has_column_privilege 
----------------------
 
(1 row)

create temp table mytable(f1 int, f2 int, f3 int);
CREATE TABLE
alter table mytable drop column f2;
ALTER TABLE
select has_column_privilege('mytable','f2','select');
psql:sql/privileges.sql:593: ERROR:  column "f2" of relation "mytable" does not exist
select has_column_privilege('mytable','........pg.dropped.2........','select');
 has_column_privilege 
----------------------
 
(1 row)

select has_column_privilege('mytable',2::int2,'select');
 has_column_privilege 
----------------------
 t
(1 row)

revoke select on table mytable from regress_priv_user3;
REVOKE
select has_column_privilege('mytable',2::int2,'select');
 has_column_privilege 
----------------------
 
(1 row)

drop table mytable;
DROP TABLE
-- Grant options
SET SESSION AUTHORIZATION regress_priv_user1;
SET
drop table if exists atest4;
psql:sql/privileges.sql:604: NOTICE:  table "atest4" does not exist, skipping
DROP TABLE
CREATE TABLE atest4 (a int);
CREATE TABLE
GRANT SELECT ON atest4 TO regress_priv_user2 WITH GRANT OPTION;
GRANT
GRANT UPDATE ON atest4 TO regress_priv_user2;
GRANT
GRANT SELECT ON atest4 TO GROUP regress_priv_group1 WITH GRANT OPTION;
GRANT
SET SESSION AUTHORIZATION regress_priv_user2;
SET
GRANT SELECT ON atest4 TO regress_priv_user3;
GRANT
GRANT UPDATE ON atest4 TO regress_priv_user3; -- fail
psql:sql/privileges.sql:614: WARNING:  no privileges were granted for "atest4"
GRANT
SET SESSION AUTHORIZATION regress_priv_user1;
SET
REVOKE SELECT ON atest4 FROM regress_priv_user3; -- does nothing
REVOKE
SELECT has_table_privilege('regress_priv_user3', 'atest4', 'SELECT'); -- true
 has_table_privilege 
---------------------
 t
(1 row)

REVOKE SELECT ON atest4 FROM regress_priv_user2; -- fail
psql:sql/privileges.sql:620: ERROR:  dependent privileges exist
HINT:  Use CASCADE to revoke them too.
REVOKE GRANT OPTION FOR SELECT ON atest4 FROM regress_priv_user2 CASCADE; -- ok
REVOKE
SELECT has_table_privilege('regress_priv_user2', 'atest4', 'SELECT'); -- true
 has_table_privilege 
---------------------
 t
(1 row)

SELECT has_table_privilege('regress_priv_user3', 'atest4', 'SELECT'); -- false
 has_table_privilege 
---------------------
 f
(1 row)

SELECT has_table_privilege('regress_priv_user1', 'atest4', 'SELECT WITH GRANT OPTION'); -- true
 has_table_privilege 
---------------------
 t
(1 row)

-- Admin options
SET SESSION AUTHORIZATION regress_priv_user4;
SET
CREATE FUNCTION dogrant_ok() RETURNS void LANGUAGE sql SECURITY DEFINER AS
	'GRANT regress_priv_group2 TO regress_priv_user5';
CREATE FUNCTION
GRANT regress_priv_group2 TO regress_priv_user5; -- ok: had ADMIN OPTION
GRANT ROLE
SET ROLE regress_priv_group2;
SET
GRANT regress_priv_group2 TO regress_priv_user5; -- fails: SET ROLE suspended privilege
psql:sql/privileges.sql:635: ERROR:  must have admin option on role "regress_priv_group2"
SET SESSION AUTHORIZATION regress_priv_user1;
SET
GRANT regress_priv_group2 TO regress_priv_user5; -- fails: no ADMIN OPTION
psql:sql/privileges.sql:638: ERROR:  must have admin option on role "regress_priv_group2"
SELECT dogrant_ok();			-- ok: SECURITY DEFINER conveys ADMIN
psql:sql/privileges.sql:639: NOTICE:  role "regress_priv_user5" is already a member of role "regress_priv_group2"
 dogrant_ok 
------------
 
(1 row)

SET ROLE regress_priv_group2;
SET
GRANT regress_priv_group2 TO regress_priv_user5; -- fails: SET ROLE did not help
psql:sql/privileges.sql:641: ERROR:  must have admin option on role "regress_priv_group2"
SET SESSION AUTHORIZATION regress_priv_group2;
SET
GRANT regress_priv_group2 TO regress_priv_user5; -- ok: a role can self-admin
psql:sql/privileges.sql:644: NOTICE:  role "regress_priv_user5" is already a member of role "regress_priv_group2"
GRANT ROLE
CREATE FUNCTION dogrant_fails() RETURNS void LANGUAGE sql SECURITY DEFINER AS
	'GRANT regress_priv_group2 TO regress_priv_user5';
CREATE FUNCTION
SELECT dogrant_fails();			-- fails: no self-admin in SECURITY DEFINER
psql:sql/privileges.sql:647: ERROR:  must have admin option on role "regress_priv_group2"
CONTEXT:  SQL function "dogrant_fails" statement 1
DROP FUNCTION dogrant_fails();
DROP FUNCTION
SET SESSION AUTHORIZATION regress_priv_user4;
SET
DROP FUNCTION dogrant_ok();
DROP FUNCTION
REVOKE regress_priv_group2 FROM regress_priv_user5;
REVOKE ROLE
-- has_sequence_privilege tests
\c -
You are now connected to database "regress" as user "abc".
CREATE SEQUENCE x_seq;
CREATE SEQUENCE
GRANT USAGE on x_seq to regress_priv_user2;
GRANT
SELECT has_sequence_privilege('regress_priv_user1', 'atest1', 'SELECT');
psql:sql/privileges.sql:662: ERROR:  "atest1" is not a sequence
SELECT has_sequence_privilege('regress_priv_user1', 'x_seq', 'INSERT');
psql:sql/privileges.sql:663: ERROR:  unrecognized privilege type: "INSERT"
SELECT has_sequence_privilege('regress_priv_user1', 'x_seq', 'SELECT');
 has_sequence_privilege 
------------------------
 f
(1 row)

SET SESSION AUTHORIZATION regress_priv_user2;
SET
SELECT has_sequence_privilege('x_seq', 'USAGE');
 has_sequence_privilege 
------------------------
 t
(1 row)

-- largeobject privilege tests
\c -
You are now connected to database "regress" as user "abc".
SET SESSION AUTHORIZATION regress_priv_user1;
SET
-- kunlun-db: large object is not supported.
--SELECT lo_create(1001);
--SELECT lo_create(1002);
--SELECT lo_create(1003);
--SELECT lo_create(1004);
--SELECT lo_create(1005);
--GRANT ALL ON LARGE OBJECT 1001 TO PUBLIC;
--GRANT SELECT ON LARGE OBJECT 1003 TO regress_priv_user2;
--GRANT SELECT,UPDATE ON LARGE OBJECT 1004 TO regress_priv_user2;
--GRANT ALL ON LARGE OBJECT 1005 TO regress_priv_user2;
--GRANT SELECT ON LARGE OBJECT 1005 TO regress_priv_user2 WITH GRANT OPTION;
--GRANT SELECT, INSERT ON LARGE OBJECT 1001 TO PUBLIC;	-- to be failed
--GRANT SELECT, UPDATE ON LARGE OBJECT 1001 TO nosuchuser;	-- to be failed
--GRANT SELECT, UPDATE ON LARGE OBJECT  999 TO PUBLIC;	-- to be failed
\c -
You are now connected to database "regress" as user "abc".
SET SESSION AUTHORIZATION regress_priv_user2;
SET
--SELECT lo_create(2001);
--SELECT lo_create(2002);
--SELECT loread(lo_open(1001, x'20000'::int), 32);	-- allowed, for now
--SELECT lowrite(lo_open(1001, x'40000'::int), 'abcd');	-- fail, wrong mode
--SELECT loread(lo_open(1001, x'40000'::int), 32);
--SELECT loread(lo_open(1002, x'40000'::int), 32);	-- to be denied
--SELECT loread(lo_open(1003, x'40000'::int), 32);
--SELECT loread(lo_open(1004, x'40000'::int), 32);
--SELECT lowrite(lo_open(1001, x'20000'::int), 'abcd');
--SELECT lowrite(lo_open(1002, x'20000'::int), 'abcd');	-- to be denied
--SELECT lowrite(lo_open(1003, x'20000'::int), 'abcd');	-- to be denied
--SELECT lowrite(lo_open(1004, x'20000'::int), 'abcd');
--GRANT SELECT ON LARGE OBJECT 1005 TO regress_priv_user3;
--GRANT UPDATE ON LARGE OBJECT 1006 TO regress_priv_user3;	-- to be denied
--REVOKE ALL ON LARGE OBJECT 2001, 2002 FROM PUBLIC;
--GRANT ALL ON LARGE OBJECT 2001 TO regress_priv_user3;
--SELECT lo_unlink(1001);		-- to be denied
--SELECT lo_unlink(2002);
\c -
You are now connected to database "regress" as user "abc".
-- confirm ACL setting
--SELECT oid, pg_get_userbyid(lomowner) ownername, lomacl FROM pg_largeobject_metadata WHERE oid >= 1000 AND oid < 3000 ORDER BY oid;
SET SESSION AUTHORIZATION regress_priv_user3;
SET
--SELECT loread(lo_open(1001, x'40000'::int), 32);
--SELECT loread(lo_open(1003, x'40000'::int), 32);	-- to be denied
--SELECT loread(lo_open(1005, x'40000'::int), 32);
--SELECT lo_truncate(lo_open(1005, x'20000'::int), 10);	-- to be denied
--SELECT lo_truncate(lo_open(2001, x'20000'::int), 10);
-- compatibility mode in largeobject permission
\c -
You are now connected to database "regress" as user "abc".
SET lo_compat_privileges = false;	-- default setting
SET
SET SESSION AUTHORIZATION regress_priv_user4;
SET
--SELECT loread(lo_open(1002, x'40000'::int), 32);	-- to be denied
--SELECT lowrite(lo_open(1002, x'20000'::int), 'abcd');	-- to be denied
--SELECT lo_truncate(lo_open(1002, x'20000'::int), 10);	-- to be denied
--SELECT lo_put(1002, 1, 'abcd');				-- to be denied
--SELECT lo_unlink(1002);					-- to be denied
--SELECT lo_export(1001, '/dev/null');			-- to be denied
--SELECT lo_import('/dev/null');				-- to be denied
--SELECT lo_import('/dev/null', 2003);			-- to be denied
\c -
You are now connected to database "regress" as user "abc".
SET lo_compat_privileges = true;	-- compatibility mode
SET
SET SESSION AUTHORIZATION regress_priv_user4;
SET
--SELECT loread(lo_open(1002, x'40000'::int), 32);
--SELECT lowrite(lo_open(1002, x'20000'::int), 'abcd');
--SELECT lo_truncate(lo_open(1002, x'20000'::int), 10);
--SELECT lo_unlink(1002);
--SELECT lo_export(1001, '/dev/null');			-- to be denied
-- don't allow unpriv users to access pg_largeobject contents
\c -
You are now connected to database "regress" as user "abc".
SELECT * FROM pg_largeobject LIMIT 0;
 loid | pageno | data 
------+--------+------
(0 rows)

SET SESSION AUTHORIZATION regress_priv_user1;
SET
SELECT * FROM pg_largeobject LIMIT 0;			-- to be denied
psql:sql/privileges.sql:763: ERROR:  permission denied for table pg_largeobject
-- test default ACLs
\c -
You are now connected to database "regress" as user "abc".
CREATE SCHEMA testns;
CREATE SCHEMA
GRANT ALL ON SCHEMA testns TO regress_priv_user1;
GRANT
CREATE TABLE testns.acltest1 (x int);
CREATE TABLE
SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'SELECT'); -- no
 has_table_privilege 
---------------------
 f
(1 row)

SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'INSERT'); -- no
 has_table_privilege 
---------------------
 f
(1 row)

ALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT SELECT ON TABLES TO public;
ALTER DEFAULT PRIVILEGES
SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'SELECT'); -- no
 has_table_privilege 
---------------------
 f
(1 row)

SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'INSERT'); -- no
 has_table_privilege 
---------------------
 f
(1 row)

DROP TABLE testns.acltest1;
DROP TABLE
CREATE TABLE testns.acltest1 (x int);
CREATE TABLE
SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'SELECT'); -- yes
 has_table_privilege 
---------------------
 t
(1 row)

SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'INSERT'); -- no
 has_table_privilege 
---------------------
 f
(1 row)

ALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT INSERT ON TABLES TO regress_priv_user1;
ALTER DEFAULT PRIVILEGES
DROP TABLE testns.acltest1;
DROP TABLE
CREATE TABLE testns.acltest1 (x int);
CREATE TABLE
SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'SELECT'); -- yes
 has_table_privilege 
---------------------
 t
(1 row)

SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'INSERT'); -- yes
 has_table_privilege 
---------------------
 t
(1 row)

ALTER DEFAULT PRIVILEGES IN SCHEMA testns REVOKE INSERT ON TABLES FROM regress_priv_user1;
ALTER DEFAULT PRIVILEGES
DROP TABLE testns.acltest1;
DROP TABLE
CREATE TABLE testns.acltest1 (x int);
CREATE TABLE
SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'SELECT'); -- yes
 has_table_privilege 
---------------------
 t
(1 row)

SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'INSERT'); -- no
 has_table_privilege 
---------------------
 f
(1 row)

ALTER DEFAULT PRIVILEGES FOR ROLE regress_priv_user1 REVOKE EXECUTE ON FUNCTIONS FROM public;
ALTER DEFAULT PRIVILEGES
ALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT USAGE ON SCHEMAS TO regress_priv_user2; -- error
psql:sql/privileges.sql:804: ERROR:  cannot use IN SCHEMA clause when using GRANT/REVOKE ON SCHEMAS
SET ROLE regress_priv_user1;
SET
CREATE FUNCTION testns.foo() RETURNS int AS 'select 1' LANGUAGE sql;
CREATE FUNCTION
CREATE AGGREGATE testns.agg1(int) (sfunc = int4pl, stype = int4);
CREATE AGGREGATE
CREATE PROCEDURE testns.bar() AS 'select 1' LANGUAGE sql;
CREATE PROCEDURE
SELECT has_function_privilege('regress_priv_user2', 'testns.foo()', 'EXECUTE'); -- no
 has_function_privilege 
------------------------
 f
(1 row)

SELECT has_function_privilege('regress_priv_user2', 'testns.agg1(int)', 'EXECUTE'); -- no
 has_function_privilege 
------------------------
 f
(1 row)

SELECT has_function_privilege('regress_priv_user2', 'testns.bar()', 'EXECUTE'); -- no
 has_function_privilege 
------------------------
 f
(1 row)

ALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT EXECUTE ON ROUTINES to public;
ALTER DEFAULT PRIVILEGES
DROP FUNCTION testns.foo();
DROP FUNCTION
CREATE FUNCTION testns.foo() RETURNS int AS 'select 1' LANGUAGE sql;
CREATE FUNCTION
DROP AGGREGATE testns.agg1(int);
DROP AGGREGATE
CREATE AGGREGATE testns.agg1(int) (sfunc = int4pl, stype = int4);
CREATE AGGREGATE
DROP PROCEDURE testns.bar();
DROP PROCEDURE
CREATE PROCEDURE testns.bar() AS 'select 1' LANGUAGE sql;
CREATE PROCEDURE
SELECT has_function_privilege('regress_priv_user2', 'testns.foo()', 'EXECUTE'); -- yes
 has_function_privilege 
------------------------
 t
(1 row)

SELECT has_function_privilege('regress_priv_user2', 'testns.agg1(int)', 'EXECUTE'); -- yes
 has_function_privilege 
------------------------
 t
(1 row)

SELECT has_function_privilege('regress_priv_user2', 'testns.bar()', 'EXECUTE'); -- yes (counts as function here)
 has_function_privilege 
------------------------
 t
(1 row)

DROP FUNCTION testns.foo();
DROP FUNCTION
DROP AGGREGATE testns.agg1(int);
DROP AGGREGATE
DROP PROCEDURE testns.bar();
DROP PROCEDURE
ALTER DEFAULT PRIVILEGES FOR ROLE regress_priv_user1 REVOKE USAGE ON TYPES FROM public;
ALTER DEFAULT PRIVILEGES
RESET ROLE;
RESET
SELECT count(*)
  FROM pg_default_acl d LEFT JOIN pg_namespace n ON defaclnamespace = n.oid
  WHERE nspname = 'testns';
 count 
-------
     2
(1 row)

  
DROP TABLE testns.acltest1;
DROP TABLE
DROP SCHEMA testns CASCADE;
DROP SCHEMA
SELECT d.*     -- check that entries went away
  FROM pg_default_acl d LEFT JOIN pg_namespace n ON defaclnamespace = n.oid
  WHERE nspname IS NULL AND defaclnamespace != 0;
 defaclrole | defaclnamespace | defaclobjtype | defaclacl 
------------+-----------------+---------------+-----------
(0 rows)

-- Grant on all objects of given type in a schema
\c -
You are now connected to database "regress" as user "abc".
CREATE SCHEMA testns;
CREATE SCHEMA
CREATE TABLE testns.t1 (f1 int);
CREATE TABLE
CREATE TABLE testns.t2 (f1 int);
CREATE TABLE
SELECT has_table_privilege('regress_priv_user1', 'testns.t1', 'SELECT'); -- false
 has_table_privilege 
---------------------
 f
(1 row)

GRANT ALL ON ALL TABLES IN SCHEMA testns TO regress_priv_user1;
GRANT
SELECT has_table_privilege('regress_priv_user1', 'testns.t1', 'SELECT'); -- true
 has_table_privilege 
---------------------
 t
(1 row)

SELECT has_table_privilege('regress_priv_user1', 'testns.t2', 'SELECT'); -- true
 has_table_privilege 
---------------------
 t
(1 row)

REVOKE ALL ON ALL TABLES IN SCHEMA testns FROM regress_priv_user1;
REVOKE
SELECT has_table_privilege('regress_priv_user1', 'testns.t1', 'SELECT'); -- false
 has_table_privilege 
---------------------
 f
(1 row)

SELECT has_table_privilege('regress_priv_user1', 'testns.t2', 'SELECT'); -- false
 has_table_privilege 
---------------------
 f
(1 row)

CREATE FUNCTION testns.priv_testfunc(int) RETURNS int AS 'select 3 * $1;' LANGUAGE sql;
CREATE FUNCTION
CREATE AGGREGATE testns.priv_testagg(int) (sfunc = int4pl, stype = int4);
CREATE AGGREGATE
CREATE PROCEDURE testns.priv_testproc(int) AS 'select 3' LANGUAGE sql;
CREATE PROCEDURE
SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testfunc(int)', 'EXECUTE'); -- true by default
 has_function_privilege 
------------------------
 t
(1 row)

SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testagg(int)', 'EXECUTE'); -- true by default
 has_function_privilege 
------------------------
 t
(1 row)

SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testproc(int)', 'EXECUTE'); -- true by default
 has_function_privilege 
------------------------
 t
(1 row)

REVOKE ALL ON ALL FUNCTIONS IN SCHEMA testns FROM PUBLIC;
REVOKE
SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testfunc(int)', 'EXECUTE'); -- false
 has_function_privilege 
------------------------
 f
(1 row)

SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testagg(int)', 'EXECUTE'); -- false
 has_function_privilege 
------------------------
 f
(1 row)

SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testproc(int)', 'EXECUTE'); -- still true, not a function
 has_function_privilege 
------------------------
 t
(1 row)

REVOKE ALL ON ALL PROCEDURES IN SCHEMA testns FROM PUBLIC;
REVOKE
SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testproc(int)', 'EXECUTE'); -- now false
 has_function_privilege 
------------------------
 f
(1 row)

GRANT ALL ON ALL ROUTINES IN SCHEMA testns TO PUBLIC;
GRANT
SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testfunc(int)', 'EXECUTE'); -- true
 has_function_privilege 
------------------------
 t
(1 row)

SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testagg(int)', 'EXECUTE'); -- true
 has_function_privilege 
------------------------
 t
(1 row)

SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testproc(int)', 'EXECUTE'); -- true
 has_function_privilege 
------------------------
 t
(1 row)

\set VERBOSITY terse \\ -- suppress cascade details
drop table testns.t1 cascade;
DROP TABLE
drop table testns.t2 cascade;
DROP TABLE
DROP SCHEMA testns CASCADE;
psql:sql/privileges.sql:895: NOTICE:  drop cascades to 3 other objects
DROP SCHEMA
\set VERBOSITY default
-- Change owner of the schema & and rename of new schema owner
\c -
You are now connected to database "regress" as user "abc".
CREATE ROLE regress_schemauser1 superuser login;
CREATE ROLE
CREATE ROLE regress_schemauser2 superuser login;
CREATE ROLE
SET SESSION ROLE regress_schemauser1;
SET
CREATE SCHEMA testns;
CREATE SCHEMA
SELECT nspname, rolname FROM pg_namespace, pg_roles WHERE pg_namespace.nspname = 'testns' AND pg_namespace.nspowner = pg_roles.oid;
 nspname |       rolname       
---------+---------------------
 testns  | regress_schemauser1
(1 row)

ALTER SCHEMA testns OWNER TO regress_schemauser2;
ALTER SCHEMA
ALTER ROLE regress_schemauser2 RENAME TO regress_schemauser_renamed;
ALTER ROLE
SELECT nspname, rolname FROM pg_namespace, pg_roles WHERE pg_namespace.nspname = 'testns' AND pg_namespace.nspowner = pg_roles.oid;
 nspname |          rolname           
---------+----------------------------
 testns  | regress_schemauser_renamed
(1 row)

set session role regress_schemauser_renamed;
SET
\set VERBOSITY terse \\ -- suppress cascade details
DROP SCHEMA testns CASCADE;
DROP SCHEMA
\set VERBOSITY default
-- clean up
\c -
You are now connected to database "regress" as user "abc".
DROP ROLE regress_schemauser1;
DROP ROLE
drop table testns.t1 cascade;
psql:sql/privileges.sql:923: ERROR:  schema "testns" does not exist
drop schema testns;
psql:sql/privileges.sql:924: ERROR:  schema "testns" does not exist
DROP ROLE regress_schemauser_renamed;
DROP ROLE
-- test that dependent privileges are revoked (or not) properly
\c -
You are now connected to database "regress" as user "abc".
set session role regress_priv_user1;
SET
create table dep_priv_test (a int);
CREATE TABLE
grant select on dep_priv_test to regress_priv_user2 with grant option;
GRANT
grant select on dep_priv_test to regress_priv_user3 with grant option;
GRANT
set session role regress_priv_user2;
SET
grant select on dep_priv_test to regress_priv_user4 with grant option;
GRANT
set session role regress_priv_user3;
SET
grant select on dep_priv_test to regress_priv_user4 with grant option;
GRANT
set session role regress_priv_user4;
SET
grant select on dep_priv_test to regress_priv_user5;
GRANT
\dp dep_priv_test
                                               Access privileges
 Schema |     Name      | Type  |               Access privileges               | Column privileges | Policies 
--------+---------------+-------+-----------------------------------------------+-------------------+----------
 public | dep_priv_test | table | regress_priv_user1=arwdDxt/regress_priv_user1+|                   | 
        |               |       | regress_priv_user2=r*/regress_priv_user1     +|                   | 
        |               |       | regress_priv_user3=r*/regress_priv_user1     +|                   | 
        |               |       | regress_priv_user4=r*/regress_priv_user2     +|                   | 
        |               |       | regress_priv_user4=r*/regress_priv_user3     +|                   | 
        |               |       | regress_priv_user5=r/regress_priv_user4       |                   | 
(1 row)

set session role regress_priv_user2;
SET
revoke select on dep_priv_test from regress_priv_user4 cascade;
REVOKE
\dp dep_priv_test
                                               Access privileges
 Schema |     Name      | Type  |               Access privileges               | Column privileges | Policies 
--------+---------------+-------+-----------------------------------------------+-------------------+----------
 public | dep_priv_test | table | regress_priv_user1=arwdDxt/regress_priv_user1+|                   | 
        |               |       | regress_priv_user2=r*/regress_priv_user1     +|                   | 
        |               |       | regress_priv_user3=r*/regress_priv_user1     +|                   | 
        |               |       | regress_priv_user4=r*/regress_priv_user3     +|                   | 
        |               |       | regress_priv_user5=r/regress_priv_user4       |                   | 
(1 row)

set session role regress_priv_user3;
SET
revoke select on dep_priv_test from regress_priv_user4 cascade;
REVOKE
\dp dep_priv_test
                                               Access privileges
 Schema |     Name      | Type  |               Access privileges               | Column privileges | Policies 
--------+---------------+-------+-----------------------------------------------+-------------------+----------
 public | dep_priv_test | table | regress_priv_user1=arwdDxt/regress_priv_user1+|                   | 
        |               |       | regress_priv_user2=r*/regress_priv_user1     +|                   | 
        |               |       | regress_priv_user3=r*/regress_priv_user1      |                   | 
(1 row)

set session role regress_priv_user1;
SET
drop table dep_priv_test;
DROP TABLE
-- clean up
\c
You are now connected to database "regress" as user "abc".
drop sequence x_seq;
DROP SEQUENCE
DROP AGGREGATE priv_testagg1(int);
DROP AGGREGATE
DROP FUNCTION priv_testfunc2(int);
DROP FUNCTION
DROP FUNCTION priv_testfunc4(boolean);
DROP FUNCTION
DROP PROCEDURE priv_testproc1(int);
DROP PROCEDURE
DROP VIEW atestv0;
DROP VIEW
DROP VIEW atestv1;
DROP VIEW
DROP VIEW atestv2;
DROP VIEW
-- this should cascade to drop atestv4
DROP VIEW atestv3 CASCADE;
psql:sql/privileges.sql:967: NOTICE:  drop cascades to view atestv4
DROP VIEW
-- this should complain "does not exist"
DROP VIEW atestv4;
psql:sql/privileges.sql:969: ERROR:  view "atestv4" does not exist
DROP TABLE atest1 cascade;
DROP TABLE
DROP TABLE atest2 cascade;
DROP TABLE
DROP TABLE atest3 cascade;
DROP TABLE
DROP TABLE atest4 cascade;
DROP TABLE
DROP TABLE atest5 cascade;
DROP TABLE
DROP TABLE atest6 cascade;
DROP TABLE
SELECT lo_unlink(oid) FROM pg_largeobject_metadata WHERE oid >= 1000 AND oid < 3000 ORDER BY oid;
 lo_unlink 
-----------
(0 rows)

DROP GROUP regress_priv_group1;
DROP ROLE
DROP GROUP regress_priv_group2;
DROP ROLE
-- these are needed to clean up permissions
REVOKE USAGE ON LANGUAGE sql FROM regress_priv_user1;
REVOKE
drop table atest12 cascade;
psql:sql/privileges.sql:985: NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to view atest12v
drop cascades to view atest12sbv
DROP TABLE
drop function leak(integer,integer) cascade;
psql:sql/privileges.sql:986: NOTICE:  drop cascades to operator <<<(integer,integer)
DROP FUNCTION
ALTER DEFAULT PRIVILEGES FOR ROLE regress_priv_user1 grant EXECUTE ON FUNCTIONS to public;
ALTER DEFAULT PRIVILEGES
ALTER DEFAULT PRIVILEGES FOR ROLE regress_priv_user1 grant USAGE ON TYPES to public;
ALTER DEFAULT PRIVILEGES
DROP USER regress_priv_user1;
DROP ROLE
DROP USER regress_priv_user2;
DROP ROLE
DROP USER regress_priv_user3;
DROP ROLE
DROP USER regress_priv_user4;
DROP ROLE
DROP USER regress_priv_user5;
DROP ROLE
DROP USER regress_priv_user6;
psql:sql/privileges.sql:995: ERROR:  role "regress_priv_user6" does not exist
-- permissions with LOCK TABLE
CREATE USER regress_locktable_user;
CREATE ROLE
CREATE TABLE lock_table (a int);
CREATE TABLE
-- LOCK TABLE and SELECT permission
GRANT SELECT ON lock_table TO regress_locktable_user;
GRANT
SET SESSION AUTHORIZATION regress_locktable_user;
SET
BEGIN;
BEGIN
LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should fail
psql:sql/privileges.sql:1006: ERROR:  permission denied for table lock_table
ROLLBACK;
ROLLBACK
BEGIN;
BEGIN
LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should pass
LOCK TABLE
COMMIT;
COMMIT
BEGIN;
BEGIN
LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should fail
psql:sql/privileges.sql:1012: ERROR:  permission denied for table lock_table
ROLLBACK
\c
You are now connected to database "regress" as user "abc".
REVOKE SELECT ON lock_table FROM regress_locktable_user;
psql:sql/privileges.sql:1015: ERROR:  syntax error at or near "REVOKE"
LINE 2: REVOKE SELECT ON lock_table FROM regress_locktable_user;
        ^
-- LOCK TABLE and INSERT permission
GRANT INSERT ON lock_table TO regress_locktable_user;
GRANT
SET SESSION AUTHORIZATION regress_locktable_user;
SET
BEGIN;
BEGIN
LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should pass
LOCK TABLE
COMMIT;
COMMIT
BEGIN;
BEGIN
LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should fail
LOCK TABLE
ROLLBACK;
ROLLBACK
BEGIN;
BEGIN
LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should fail
psql:sql/privileges.sql:1027: ERROR:  permission denied for table lock_table
ROLLBACK;
ROLLBACK
\c
You are now connected to database "regress" as user "abc".
REVOKE INSERT ON lock_table FROM regress_locktable_user;
REVOKE
-- LOCK TABLE and UPDATE permission
GRANT UPDATE ON lock_table TO regress_locktable_user;
GRANT
SET SESSION AUTHORIZATION regress_locktable_user;
SET
BEGIN;
BEGIN
LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should pass
LOCK TABLE
COMMIT;
COMMIT
BEGIN;
BEGIN
LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should fail
LOCK TABLE
ROLLBACK;
ROLLBACK
BEGIN;
BEGIN
LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should pass
LOCK TABLE
COMMIT;
COMMIT
\c
You are now connected to database "regress" as user "abc".
REVOKE UPDATE ON lock_table FROM regress_locktable_user;
REVOKE
-- LOCK TABLE and DELETE permission
GRANT DELETE ON lock_table TO regress_locktable_user;
GRANT
SET SESSION AUTHORIZATION regress_locktable_user;
SET
BEGIN;
BEGIN
LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should pass
LOCK TABLE
COMMIT;
COMMIT
BEGIN;
BEGIN
LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should fail
LOCK TABLE
ROLLBACK;
ROLLBACK
BEGIN;
BEGIN
LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should pass
LOCK TABLE
COMMIT;
COMMIT
\c
You are now connected to database "regress" as user "abc".
REVOKE DELETE ON lock_table FROM regress_locktable_user;
REVOKE
SET SESSION AUTHORIZATION regress_locktable_user;
SET
BEGIN;
BEGIN
LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should pass
psql:sql/privileges.sql:1064: ERROR:  permission denied for table lock_table
COMMIT;
ROLLBACK
BEGIN;
BEGIN
LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should fail
LOCK TABLE
ROLLBACK;
ROLLBACK
BEGIN;
BEGIN
LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should pass
psql:sql/privileges.sql:1070: ERROR:  permission denied for table lock_table
COMMIT;
ROLLBACK
\c
You are now connected to database "regress" as user "abc".
-- clean up
DROP TABLE lock_table;
DROP TABLE
DROP USER regress_locktable_user;
DROP ROLE
